<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.290">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Mark Spillman">
<meta name="dcterms.date" content="2023-09-08">
<meta name="description" content="Generating synthetic powder X-ray diffraction data for machine learning applications">

<title>Mark Spillman - Generating synthetic diffraction data from PowCod database</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-EVMREB130B"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-EVMREB130B', { 'anonymize_ip': true});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Mark Spillman</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html" rel="" target="">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../publications.html" rel="" target="">
 <span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../subscribe.html" rel="" target="">
 <span class="menu-text">Subscribe</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/mspillman" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/mspillman" rel="" target=""><i class="bi bi-twitter" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Generating synthetic diffraction data from PowCod database</h1>
                  <div>
        <div class="description">
          Generating synthetic powder X-ray diffraction data for machine learning applications
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">PXRD</div>
                <div class="quarto-category">Machine learning</div>
                <div class="quarto-category">Synthetic data</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Mark Spillman </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">September 8, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#synthetic-diffraction-data-using-the-powcod-database" id="toc-synthetic-diffraction-data-using-the-powcod-database" class="nav-link" data-scroll-target="#synthetic-diffraction-data-using-the-powcod-database">Synthetic Diffraction data using the PowCod database</a>
  <ul class="collapse">
  <li><a href="#filtering-powcod-data" id="toc-filtering-powcod-data" class="nav-link" data-scroll-target="#filtering-powcod-data">Filtering PowCod data</a>
  <ul class="collapse">
  <li><a href="#unit-cell-dimensions-and-volume" id="toc-unit-cell-dimensions-and-volume" class="nav-link" data-scroll-target="#unit-cell-dimensions-and-volume">Unit cell dimensions and volume</a></li>
  <li><a href="#diffraction-data" id="toc-diffraction-data" class="nav-link" data-scroll-target="#diffraction-data">Diffraction data</a></li>
  <li><a href="#saving-the-filtered-data" id="toc-saving-the-filtered-data" class="nav-link" data-scroll-target="#saving-the-filtered-data">Saving the filtered data</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#generating-synthetic-data" id="toc-generating-synthetic-data" class="nav-link" data-scroll-target="#generating-synthetic-data">Generating synthetic data</a>
  <ul class="collapse">
  <li><a href="#peak-positions" id="toc-peak-positions" class="nav-link" data-scroll-target="#peak-positions">Peak positions</a></li>
  <li><a href="#peak-intensities" id="toc-peak-intensities" class="nav-link" data-scroll-target="#peak-intensities">Peak intensities</a></li>
  <li><a href="#peak-shapes" id="toc-peak-shapes" class="nav-link" data-scroll-target="#peak-shapes">Peak shapes</a></li>
  <li><a href="#background-and-noise" id="toc-background-and-noise" class="nav-link" data-scroll-target="#background-and-noise">Background and noise</a></li>
  </ul></li>
  <li><a href="#performance" id="toc-performance" class="nav-link" data-scroll-target="#performance">Performance</a></li>
  <li><a href="#powcod-generated-data" id="toc-powcod-generated-data" class="nav-link" data-scroll-target="#powcod-generated-data">PowCod generated data</a></li>
  <li><a href="#conclusions" id="toc-conclusions" class="nav-link" data-scroll-target="#conclusions">Conclusions</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Neural networks have become a powerful tool for automating complex tasks in crystallography, including PXRD data analysis. For example, <a href="https://scripts.iucr.org/cgi-bin/paper?vb5020">indexing</a>, <a href="https://www.nature.com/articles/s41524-021-00542-4">crystallite size and scale factor</a> determination, as well as <a href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.99.245120">crystal system and space group</a> <a href="https://journals.iucr.org/m/issues/2017/04/00/fc5018/index.html">classification</a>. There are many more examples in the literature! In future posts, we’ll look at how to train our own neural networks for analysing PXRD data. However, before we get there, we’ll need a large volume of PXRD against which they can be trained.</p>
<p>To the best of my knowledge, there is no extant database of experimental PXRD patterns. However, there are several databases, such as the <a href="http://www.crystallography.net/cod/">COD</a>, CCDC’s <a href="https://www.ccdc.cam.ac.uk/solutions/software/csd/">CSD</a> and ICDD’s <a href="https://www.icdd.com/">PDF</a>, which provide experimental crystal structures. These databases, which contain hundreds of thousands of crystal structures can then be used to calculate diffraction patterns. The CSD has a <a href="https://downloads.ccdc.cam.ac.uk/documentation/API/">python API</a> which allows PXRD data to be generated for each of the entries in the database. However, this is not optimised to run quickly, and as such, PXRD data would need to be generated in advance.</p>
<p>In this post, we’ll look at how we can efficiently calculate large numbers of diffraction patterns <em>on-the-fly</em> whilst training neural networks. By writing our own code to generate synthetic PXRD data, we will also be able to implement various <em>data augmentation</em> transformations. Such transformations make the calculated PXRD data look different from the perspective of a machine learning algorithm, but could still plausibly be produced by the same underlying material. This will help to make our future neural networks more robust and able to be applied to real-world diffraction data.</p>
</section>
<section id="synthetic-diffraction-data-using-the-powcod-database" class="level1">
<h1>Synthetic Diffraction data using the PowCod database</h1>
<p>I used the <a href="https://www.researchgate.net/publication/273507012_QUALX20_A_qualitative_phase_analysis_software_using_the_freely_available_database_POW-COD">PowCod database</a> produced by the <a href="https://www.ba.ic.cnr.it/softwareic/qualx/powcod-download/">Bari group</a> as the source for the diffraction data. This database is based on the COD, and for each entry, a Powder X-ray diffraction pattern has been calculated. This is saved in PowCod in the form of the Miller indices of each reflection, the associated intensity, the d-spacing and other relevant information (e.g.&nbsp;multiplicity etc). Being able to read in this information directly, rather than having to calculate this for each of the crystal structures makes this work significantly easier.</p>
<p>As described earlier, PowCod provides lots of information. Most pertinent for this work is the unit cells, space groups, Miller indices and associated intensities for all of the crystal structures. In the next sections, we’ll look at how I filtered the PowCod database, and then discuss the PyTorch-based code I’ve written to generate relatively realistic looking PXRD data on-the-fly using my GPU.</p>
<p>I’ve included several methods of data augmentation:</p>
<ul>
<li>Modification of unit cells to simulate thermal expansion / contraction</li>
<li>Modification of intensities using the March-Dollase method to simulate preferred orientation effects</li>
<li>Modification of peak shapes, broadening and asymmetry to simulate different crystallite sizes/strains and instrumentation</li>
<li>Modification of zero point errors to simulate different instruments</li>
<li>Modification of noise to simulate different experimental data collection times / sample sizes</li>
</ul>
<section id="filtering-powcod-data" class="level2">
<h2 class="anchored" data-anchor-id="filtering-powcod-data">Filtering PowCod data</h2>
<p>The PowCod database, which can be obtained <a href="https://www.ba.ic.cnr.it/softwareic/qualx/powcod-download/">here</a>, is made up of several .sql files which need to be parsed to extract the desired information. In our case, what we are after is:</p>
<ul>
<li>Unit cells</li>
<li>Crystal systems</li>
<li>Space groups</li>
<li>Miller indices</li>
<li>Intensities</li>
</ul>
<p>We’ll probably also need to use some additional information to help us along the way, for example, the d-spacing of the reflections.</p>
<p>As the files total only around 5.5 GB, I used pandas to read the database into memory and extract the information needed. I pickled the resultant dataframe to enable it to be more easily read in the future.</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> read_powcod_sql():</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> sqlite3</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    con <span class="op">=</span> sqlite3.<span class="ex">connect</span>(<span class="st">'cod2205.sq'</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.read_sql_query(<span class="st">'SELECT * FROM id'</span>,con)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    con2 <span class="op">=</span> sqlite3.<span class="ex">connect</span>(<span class="st">'cod2205.sq.info'</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    df2 <span class="op">=</span> pd.read_sql_query(<span class="st">'SELECT * FROM info'</span>,con2)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    df.<span class="bu">id</span> <span class="op">=</span> pd.to_numeric(df.<span class="bu">id</span>)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    df2.<span class="bu">id</span> <span class="op">=</span> pd.to_numeric(df2.<span class="bu">id</span>)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    combined <span class="op">=</span> df.merge(df2, left_on<span class="op">=</span><span class="st">"id"</span>, right_on<span class="op">=</span><span class="st">"id"</span>)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> combined</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> os.path.isfile(<span class="st">"combined.pkl"</span>):</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    combined <span class="op">=</span> pd.read_pickle(<span class="st">"combined.pkl"</span>)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    combined <span class="op">=</span> read_powcod_sql()</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(combined.columns)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    combined <span class="op">=</span> combined[[<span class="st">"spacegroup_x"</span>, <span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c"</span>, <span class="st">"alpha"</span>, <span class="st">"beta"</span>,</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>                    <span class="st">"gamma"</span>, <span class="st">"volume"</span>, <span class="st">"h"</span>, <span class="st">"k"</span>, <span class="st">"l"</span>, <span class="st">"nd"</span>, <span class="st">"dvalue"</span>,</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>                    <span class="st">"intensita"</span>, <span class="st">"type"</span>, <span class="st">"id"</span>]]</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    combined.to_pickle(<span class="st">"combined.pkl"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s have a look at what we’ve got:</p>
<div class="cell" data-execution_count="5">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>combined</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="5">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">spacegroup_x</th>
<th data-quarto-table-cell-role="th">a</th>
<th data-quarto-table-cell-role="th">b</th>
<th data-quarto-table-cell-role="th">c</th>
<th data-quarto-table-cell-role="th">alpha</th>
<th data-quarto-table-cell-role="th">beta</th>
<th data-quarto-table-cell-role="th">gamma</th>
<th data-quarto-table-cell-role="th">volume</th>
<th data-quarto-table-cell-role="th">h</th>
<th data-quarto-table-cell-role="th">k</th>
<th data-quarto-table-cell-role="th">l</th>
<th data-quarto-table-cell-role="th">nd</th>
<th data-quarto-table-cell-role="th">dvalue</th>
<th data-quarto-table-cell-role="th">intensita</th>
<th data-quarto-table-cell-role="th">type</th>
<th data-quarto-table-cell-role="th">id</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>C m c m</td>
<td>0.0000</td>
<td>0.0000</td>
<td>0.0000</td>
<td>0.0</td>
<td>0.000</td>
<td>0.0</td>
<td>738.078</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0.000000</td>
<td>0.000000</td>
<td>Orthorhombic</td>
<td>1010866</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>I 4/m m m</td>
<td>0.0000</td>
<td>0.0000</td>
<td>0.0000</td>
<td>0.0</td>
<td>0.000</td>
<td>0.0</td>
<td>388.473</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0.000000</td>
<td>0.000000</td>
<td>Tetragonal</td>
<td>6000382</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>P -1</td>
<td>0.0000</td>
<td>0.0000</td>
<td>0.0000</td>
<td>0.0</td>
<td>0.000</td>
<td>0.0</td>
<td>429.928</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0.000000</td>
<td>0.000000</td>
<td>Triclinic</td>
<td>6000073</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>P -3</td>
<td>0.0000</td>
<td>0.0000</td>
<td>0.0000</td>
<td>0.0</td>
<td>0.000</td>
<td>0.0</td>
<td>1221.297</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0.000000</td>
<td>0.000000</td>
<td>Trigonal (hexagonal axes)</td>
<td>6000152</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>P 1</td>
<td>0.0000</td>
<td>0.0000</td>
<td>0.0000</td>
<td>0.0</td>
<td>0.000</td>
<td>0.0</td>
<td>552.983</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0.000000</td>
<td>0.000000</td>
<td>Cubic</td>
<td>6000430</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">458155</td>
<td>P 1 21 1</td>
<td>6.6330</td>
<td>15.4171</td>
<td>11.9417</td>
<td>90.0</td>
<td>103.335</td>
<td>90.0</td>
<td>1188.257</td>
<td>0,0,0,1,0,1,1,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,1,...</td>
<td>0,1,2,0,2,0,1,1,0,1,0,2,0,1,2,3,1,2,2,2,3,3,0,...</td>
<td>1,1,0,0,1,-1,0,-1,2,2,1,0,-2,1,-1,1,-2,2,1,-2,...</td>
<td>499</td>
<td>11.619700,9.279300,7.708500,6.454200,6.423600,...</td>
<td>1000.000000,62.638200,82.940500,3.929300,0.067...</td>
<td>Monoclinic</td>
<td>4344045</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">458156</td>
<td>C 1 2/m 1</td>
<td>21.2287</td>
<td>17.8117</td>
<td>12.3055</td>
<td>90.0</td>
<td>124.759</td>
<td>90.0</td>
<td>3822.662</td>
<td>1,1,0,2,0,2,0,2,1,3,2,2,1,1,3,3,1,2,4,2,0,4,1,...</td>
<td>1,1,0,0,2,0,2,2,1,1,2,0,3,1,1,1,3,0,0,2,0,0,3,...</td>
<td>0,-1,1,-1,0,0,1,-1,1,-1,0,-2,0,-2,0,-2,-1,1,-1...</td>
<td>498</td>
<td>12.461500,10.123800,10.109700,9.999700,8.90580...</td>
<td>1000.000000,1.459300,384.189200,186.432500,88....</td>
<td>Monoclinic</td>
<td>4123491</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">458157</td>
<td>C 1 2/m 1</td>
<td>21.5314</td>
<td>18.0366</td>
<td>12.3918</td>
<td>90.0</td>
<td>124.872</td>
<td>90.0</td>
<td>3948.216</td>
<td>1,1,0,2,0,2,0,2,1,3,2,2,1,3,1,3,1,2,4,2,0,4,1,...</td>
<td>1,1,0,0,2,0,2,2,1,1,2,0,3,1,1,1,3,0,0,2,0,0,3,...</td>
<td>0,-1,1,-1,0,0,1,-1,1,-1,0,-2,0,0,-2,-2,-1,1,-1...</td>
<td>498</td>
<td>12.620300,10.213500,10.166600,10.122700,9.0183...</td>
<td>1000.000000,0.425500,401.199700,131.443500,109...</td>
<td>Monoclinic</td>
<td>4123492</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">458158</td>
<td>I -4 2 m</td>
<td>10.2400</td>
<td>10.2400</td>
<td>9.6520</td>
<td>90.0</td>
<td>90.000</td>
<td>90.0</td>
<td>1012.086</td>
<td>1,1,2,0,2,1,2,2,3,3,1,2,3,3,2,4,3,0,4,3,4,1,4,...</td>
<td>1,0,0,0,1,1,2,0,1,0,0,2,2,1,1,0,3,0,1,0,2,1,0,...</td>
<td>0,1,0,2,1,2,0,2,0,1,3,2,1,2,3,0,0,4,1,3,0,4,2,...</td>
<td>302</td>
<td>7.240800,7.023700,5.120000,4.826000,4.137400,4...</td>
<td>435.793700,1000.000000,156.773800,74.174400,1....</td>
<td>Tetragonal</td>
<td>1508227</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">458159</td>
<td>P n a 21</td>
<td>10.3130</td>
<td>8.1940</td>
<td>4.9930</td>
<td>90.0</td>
<td>90.000</td>
<td>90.0</td>
<td>421.932</td>
<td>1,2,2,0,0,1,1,2,2,2,3,1,2,3,1,3,4,0,4,2,0,1,3,...</td>
<td>1,0,1,1,2,1,2,0,1,2,1,2,2,1,3,2,0,0,1,3,3,3,2,...</td>
<td>0,0,0,1,0,1,0,1,1,0,0,1,1,1,0,0,0,2,0,0,1,1,1,...</td>
<td>484</td>
<td>6.415500,5.156500,4.364200,4.263800,4.097000,3...</td>
<td>884.735400,207.638600,175.487800,594.721200,42...</td>
<td>Orthorhombic</td>
<td>8103382</td>
</tr>
</tbody>
</table>

<p>458160 rows × 16 columns</p>
</div>
</div>
</div>
<div class="cell" data-execution_count="6">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>combined.describe()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="6">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">a</th>
<th data-quarto-table-cell-role="th">b</th>
<th data-quarto-table-cell-role="th">c</th>
<th data-quarto-table-cell-role="th">alpha</th>
<th data-quarto-table-cell-role="th">beta</th>
<th data-quarto-table-cell-role="th">gamma</th>
<th data-quarto-table-cell-role="th">volume</th>
<th data-quarto-table-cell-role="th">nd</th>
<th data-quarto-table-cell-role="th">id</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">count</td>
<td>458160.000000</td>
<td>458160.000000</td>
<td>458160.000000</td>
<td>458160.000000</td>
<td>458160.000000</td>
<td>458160.000000</td>
<td>458160.000000</td>
<td>458160.000000</td>
<td>4.581600e+05</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">mean</td>
<td>12.505100</td>
<td>13.372528</td>
<td>16.330272</td>
<td>89.503372</td>
<td>95.199651</td>
<td>90.906179</td>
<td>3178.613746</td>
<td>454.593930</td>
<td>4.604041e+06</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">std</td>
<td>6.874009</td>
<td>6.655914</td>
<td>8.092967</td>
<td>8.326557</td>
<td>11.649541</td>
<td>10.924374</td>
<td>6384.755145</td>
<td>119.026662</td>
<td>2.281053e+06</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">min</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>1.000000</td>
<td>1.000000e+06</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">25%</td>
<td>8.282900</td>
<td>9.153000</td>
<td>11.279975</td>
<td>90.000000</td>
<td>90.000000</td>
<td>90.000000</td>
<td>1089.974000</td>
<td>498.000000</td>
<td>2.221300e+06</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">50%</td>
<td>10.780000</td>
<td>12.130000</td>
<td>15.169000</td>
<td>90.000000</td>
<td>92.430000</td>
<td>90.000000</td>
<td>1976.458000</td>
<td>499.000000</td>
<td>4.302406e+06</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">75%</td>
<td>14.703000</td>
<td>16.140000</td>
<td>19.860000</td>
<td>90.000000</td>
<td>101.688000</td>
<td>90.000000</td>
<td>3562.973750</td>
<td>500.000000</td>
<td>7.046806e+06</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">max</td>
<td>189.800000</td>
<td>150.000000</td>
<td>475.977800</td>
<td>150.172000</td>
<td>173.895000</td>
<td>149.900000</td>
<td>740478.188000</td>
<td>500.000000</td>
<td>9.016730e+06</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div class="cell" data-execution_count="7">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">4</span>, figsize<span class="op">=</span>(<span class="dv">18</span>,<span class="dv">7</span>))</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>sns.kdeplot(combined.a, ax<span class="op">=</span>ax[<span class="dv">0</span>][<span class="dv">0</span>])</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>sns.kdeplot(combined.b, ax<span class="op">=</span>ax[<span class="dv">0</span>][<span class="dv">1</span>])</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>sns.kdeplot(combined.c, ax<span class="op">=</span>ax[<span class="dv">0</span>][<span class="dv">2</span>])</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>sns.kdeplot(combined.volume, ax<span class="op">=</span>ax[<span class="dv">0</span>][<span class="dv">3</span>])</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>sns.kdeplot(combined.alpha, ax<span class="op">=</span>ax[<span class="dv">1</span>][<span class="dv">0</span>])</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>sns.kdeplot(combined.beta, ax<span class="op">=</span>ax[<span class="dv">1</span>][<span class="dv">1</span>])</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>sns.kdeplot(combined.gamma, ax<span class="op">=</span>ax[<span class="dv">1</span>][<span class="dv">2</span>])</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>sns.kdeplot(combined.nd, ax<span class="op">=</span>ax[<span class="dv">1</span>][<span class="dv">3</span>])</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>):</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        ax[i][j<span class="op">+</span><span class="dv">1</span>].set_ylabel(<span class="st">""</span>)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="2023-09-08-Generating-synthetic-PXRD-data_files/figure-html/cell-5-output-1.png" class="quarto-discovered-preview-image img-fluid"></p>
</div>
</div>
<p>We’re starting off with 458k samples, but a lot of these won’t be useful for us. I’m choosing to focus on materials with relatively small unit cells, and attempting to generate realistic looking <em>laboratory</em> diffraction data.</p>
<p>We can see that some unit cells are listed as having zero volume, and have a value of 0 for the unit cell lengths and angles. Our goal of modifying unit cells and using them to generate the diffraction data as a form of data augmentation means that these entries are not useful to us, so we’ll need to remove them. We can also see that there are some monstrous unit cells in there, with volumes of &gt;700,000 Å³!</p>
<p>To make things manageable for future machine learning projects, we’re going to set limits on the allowable unit cell dimensions and volumes. Let’s set the lower and upper limits for volume to 400 and 4000 Å³ respectively, and set the maximum unit cell length to 50 Å. We can also see some unusual looking unit cell angles, so I’m going to trim entries with cell angles below 60 and above 120 degrees (keeping 120 degrees is important to ensure we keep hexagonal unit cells).</p>
<p>Eventually, we’re going to generate diffraction data. I’ve chosen to focus on realistic looking laboratory diffraction data, and hence I’m choosing to work in the (arbirarily chosen!) range 4 - 44 ° <span class="math inline">\(2\theta\)</span> with Cu K-α1 radiation. We’ll want to ensure that there are at least a few easily detectable peaks within this chosen range. I’ll set the lower bound for this as 10.</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>min_volume <span class="op">=</span> <span class="dv">400</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>max_volume <span class="op">=</span> <span class="dv">4000</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>max_cell_length <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>min_cell_angle <span class="op">=</span> <span class="dv">60</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>max_cell_angle <span class="op">=</span> <span class="dv">120</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>min_data_angle <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>max_data_angle <span class="op">=</span> <span class="dv">44</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>wavelength <span class="op">=</span> <span class="fl">1.54056</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>min_detectable_peaks_in_range <span class="op">=</span> <span class="dv">10</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="unit-cell-dimensions-and-volume" class="level3">
<h3 class="anchored" data-anchor-id="unit-cell-dimensions-and-volume">Unit cell dimensions and volume</h3>
<p>Let’s first filter by the unit cell restrictions on volume, lengths and angles. We can also filter by the number of d-spacings (in the column <code>nd</code>) though we will need to come back to this again later to check that the remaining reflections are both in the range desired and also have reasonable intensities.</p>
<div class="cell" data-execution_count="9">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>combined <span class="op">=</span> combined[(combined.volume <span class="op">&lt;=</span> max_volume) <span class="op">&amp;</span> (combined.volume <span class="op">&gt;=</span> min_volume)]</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>combined <span class="op">=</span> combined[(combined.a <span class="op">!=</span> <span class="dv">0</span>) <span class="op">&amp;</span> (combined.b <span class="op">!=</span> <span class="dv">0</span>) <span class="op">&amp;</span> (combined.c <span class="op">!=</span> <span class="dv">0</span>)]</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>combined <span class="op">=</span> combined[(combined.a <span class="op">&lt;=</span> max_cell_length) <span class="op">&amp;</span> (combined.b <span class="op">&lt;=</span> max_cell_length) <span class="op">&amp;</span> (combined.c <span class="op">&lt;=</span> max_cell_length)]</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>combined <span class="op">=</span> combined[(combined.alpha <span class="op">&gt;=</span> min_cell_angle) <span class="op">&amp;</span> (combined.alpha <span class="op">&lt;=</span> max_cell_angle)]</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>combined <span class="op">=</span> combined[(combined.beta <span class="op">&gt;=</span> min_cell_angle) <span class="op">&amp;</span> (combined.beta <span class="op">&lt;=</span> max_cell_angle)]</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>combined <span class="op">=</span> combined[(combined.gamma <span class="op">&gt;=</span> min_cell_angle) <span class="op">&amp;</span> (combined.gamma <span class="op">&lt;=</span> max_cell_angle)]</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>combined <span class="op">=</span> combined[(combined.nd <span class="op">&gt;=</span> min_detectable_peaks_in_range)]</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>combined.describe()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="9">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">a</th>
<th data-quarto-table-cell-role="th">b</th>
<th data-quarto-table-cell-role="th">c</th>
<th data-quarto-table-cell-role="th">alpha</th>
<th data-quarto-table-cell-role="th">beta</th>
<th data-quarto-table-cell-role="th">gamma</th>
<th data-quarto-table-cell-role="th">volume</th>
<th data-quarto-table-cell-role="th">nd</th>
<th data-quarto-table-cell-role="th">id</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">count</td>
<td>324333.000000</td>
<td>324333.000000</td>
<td>324333.000000</td>
<td>324333.000000</td>
<td>324333.000000</td>
<td>324333.000000</td>
<td>324333.000000</td>
<td>324333.000000</td>
<td>3.243330e+05</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">mean</td>
<td>10.992746</td>
<td>12.400612</td>
<td>15.034673</td>
<td>89.719327</td>
<td>94.956107</td>
<td>90.499324</td>
<td>1849.638022</td>
<td>477.448866</td>
<td>4.549946e+06</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">std</td>
<td>4.372923</td>
<td>4.840500</td>
<td>5.626536</td>
<td>7.474114</td>
<td>9.913211</td>
<td>9.476333</td>
<td>931.743127</td>
<td>81.543710</td>
<td>2.265363e+06</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">min</td>
<td>2.808500</td>
<td>2.820000</td>
<td>2.718100</td>
<td>60.019000</td>
<td>60.130000</td>
<td>60.000000</td>
<td>400.059000</td>
<td>16.000000</td>
<td>1.000000e+06</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">25%</td>
<td>8.236400</td>
<td>9.237500</td>
<td>11.247500</td>
<td>90.000000</td>
<td>90.000000</td>
<td>90.000000</td>
<td>1085.857000</td>
<td>498.000000</td>
<td>2.219163e+06</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">50%</td>
<td>10.114500</td>
<td>11.585500</td>
<td>14.365300</td>
<td>90.000000</td>
<td>93.216000</td>
<td>90.000000</td>
<td>1699.288000</td>
<td>499.000000</td>
<td>4.129720e+06</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">75%</td>
<td>12.609000</td>
<td>14.506900</td>
<td>17.908600</td>
<td>90.000000</td>
<td>101.601000</td>
<td>90.000000</td>
<td>2515.215000</td>
<td>500.000000</td>
<td>7.047435e+06</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">max</td>
<td>49.953000</td>
<td>49.977000</td>
<td>49.944000</td>
<td>119.990000</td>
<td>120.000000</td>
<td>120.000000</td>
<td>3999.991000</td>
<td>500.000000</td>
<td>9.016729e+06</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>That’s a fairly significant reduction in the number of samples - the size of the dataset has gone down by over 100k! However, hopefully we’ve now gotten rid of most of the really odd or unusable samples in the dataset, and the remaining filtering won’t have such a drastic effect on the remaining entries.</p>
<p>Let’s now replot the kernel density plots we saw earlier and see how things look after the filtering.</p>
<div class="cell" data-execution_count="10">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">4</span>, figsize<span class="op">=</span>(<span class="dv">18</span>,<span class="dv">7</span>))</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>sns.kdeplot(combined.a, ax<span class="op">=</span>ax[<span class="dv">0</span>][<span class="dv">0</span>])</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>sns.kdeplot(combined.b, ax<span class="op">=</span>ax[<span class="dv">0</span>][<span class="dv">1</span>])</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>sns.kdeplot(combined.c, ax<span class="op">=</span>ax[<span class="dv">0</span>][<span class="dv">2</span>])</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>sns.kdeplot(combined.volume, ax<span class="op">=</span>ax[<span class="dv">0</span>][<span class="dv">3</span>])</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>sns.kdeplot(combined.alpha, ax<span class="op">=</span>ax[<span class="dv">1</span>][<span class="dv">0</span>])</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>sns.kdeplot(combined.beta, ax<span class="op">=</span>ax[<span class="dv">1</span>][<span class="dv">1</span>])</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>sns.kdeplot(combined.gamma, ax<span class="op">=</span>ax[<span class="dv">1</span>][<span class="dv">2</span>])</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>sns.kdeplot(combined.nd, ax<span class="op">=</span>ax[<span class="dv">1</span>][<span class="dv">3</span>])</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="2023-09-08-Generating-synthetic-PXRD-data_files/figure-html/cell-8-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Things look a bit nicer now! Just out of interest, we’ll take a quick look at the distribution of crystal systems and space groups. Other work looking at the CSD and other databases has shown a significant imbalance in the number of crystal structures adopting each crystal system and indeed space group.</p>
<div class="cell" data-execution_count="11">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>combined.<span class="bu">type</span>.value_counts().sort_values().iloc[::<span class="op">-</span><span class="dv">1</span>].head(<span class="dv">20</span>).plot.bar()</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="2023-09-08-Generating-synthetic-PXRD-data_files/figure-html/cell-9-output-1.png" class="img-fluid"></p>
</div>
</div>
<div class="cell" data-execution_count="12">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>combined.spacegroup_x.value_counts().sort_values().iloc[::<span class="op">-</span><span class="dv">1</span>].head(<span class="dv">20</span>).plot.bar()</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="2023-09-08-Generating-synthetic-PXRD-data_files/figure-html/cell-10-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Unsurprisingly, we see that some space groups are much more highly represented than others. If we decide to try crystal system, space group or extinction symbol classification using this data, we will need to keep this fairly severe class imbalance in mind!</p>
<p>For convenience for future work, it’d be good to convert these labels into their international tables numbers. Let’s write a quick function to do that, getting rid of any entries that have unknown space groups, or space group labels that are otherwise difficult to interpret.</p>
<div class="cell" data-execution_count="13">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pymatgen.symmetry <span class="im">import</span> groups</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>symbol_to_num <span class="op">=</span> {}</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, s <span class="kw">in</span> <span class="bu">enumerate</span>(np.unique(combined.spacegroup_x.to_numpy())):</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        g <span class="op">=</span> groups.SpaceGroup(s)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        symbol_to_num[s] <span class="op">=</span> g.int_number</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span>:</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        symbol_to_num[s] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> label_SGs(sg):</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> symbol_to_num[sg]</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>combined[<span class="st">"sg_number"</span>] <span class="op">=</span> combined.spacegroup_x.<span class="bu">apply</span>(label_SGs)</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>combined <span class="op">=</span> combined[combined.sg_number <span class="op">&gt;</span> <span class="dv">0</span>]</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>combined.sg_number.describe()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="13">
<pre><code>count    323694.000000
mean         24.984507
std          44.618451
min           1.000000
25%           2.000000
50%          14.000000
75%          15.000000
max         230.000000
Name: sg_number, dtype: float64</code></pre>
</div>
</div>
<p>We lost &lt;1000 entries in that step, which is good news!</p>
</section>
<section id="diffraction-data" class="level3">
<h3 class="anchored" data-anchor-id="diffraction-data">Diffraction data</h3>
<p>We can now turn our attention to the diffraction data - the intensities, Miller indices and d-spacings. Some of the entries will have a huge number of peaks, some will have very few. To start with, I’m choosing to exclude samples that have reflections <em>below</em> the bottom of our data range. I also want to ensure that there is still at least one peak <em>above</em> the top end of our data range which ensures that we aren’t missing any data <em>inside</em> our chosen data range.</p>
<p>Our dataframe contains the d-spacings for the observed reflections, so using Bragg’s law we can easily convert the angular range bounds into d-spacings, and then apply the filtering just described.</p>
<div class="cell" data-execution_count="11">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>d_from_tt <span class="op">=</span> <span class="kw">lambda</span> x: wavelength<span class="op">/</span>(<span class="dv">2</span><span class="op">*</span>np.sin(np.deg2rad(x)<span class="op">/</span><span class="dv">2</span>))</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>tt_from_d <span class="op">=</span> <span class="kw">lambda</span> x: <span class="dv">2</span><span class="op">*</span>np.rad2deg(np.arcsin(wavelength<span class="op">/</span>(<span class="dv">2</span><span class="op">*</span>x)))</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>max_d <span class="op">=</span> d_from_tt(min_data_angle)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>min_d <span class="op">=</span> d_from_tt(max_data_angle)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Wavelength:"</span>, wavelength)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Minimum angle = </span><span class="sc">{</span>min_data_angle<span class="sc">}</span><span class="ss">  : Maximum d-spacing = </span><span class="sc">{</span>max_d<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Maximum angle = </span><span class="sc">{</span>max_data_angle<span class="sc">}</span><span class="ss"> : Minimum d-spacing = </span><span class="sc">{</span>min_d<span class="sc">:.3f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Wavelength: 1.54056
Minimum angle = 4  : Maximum d-spacing = 22.071
Maximum angle = 44 : Minimum d-spacing = 2.056</code></pre>
</div>
</div>
<div class="cell" data-execution_count="12">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> d_spacing_limits(x, min_d_spacing<span class="op">=</span><span class="dv">1</span>, max_d_spacing<span class="op">=</span><span class="dv">100</span>):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> <span class="bu">list</span>(<span class="bu">filter</span>(<span class="va">None</span>, x.strip().split(<span class="st">","</span>)))</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> [<span class="bu">float</span>(i) <span class="cf">for</span> i <span class="kw">in</span> d]</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(d) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> d[<span class="op">-</span><span class="dv">1</span>] <span class="op">&gt;</span> min_d_spacing:</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> d[<span class="dv">0</span>] <span class="op">&gt;</span> max_d_spacing:</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>combined[<span class="st">"d_spacing_filter"</span>] <span class="op">=</span> combined.dvalue.<span class="bu">apply</span>(d_spacing_limits, args<span class="op">=</span>(min_d, max_d))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="13">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>combined <span class="op">=</span> combined[combined[<span class="st">"d_spacing_filter"</span>] <span class="op">==</span> <span class="va">True</span>]</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>combined.describe()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="13">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">a</th>
<th data-quarto-table-cell-role="th">b</th>
<th data-quarto-table-cell-role="th">c</th>
<th data-quarto-table-cell-role="th">alpha</th>
<th data-quarto-table-cell-role="th">beta</th>
<th data-quarto-table-cell-role="th">gamma</th>
<th data-quarto-table-cell-role="th">volume</th>
<th data-quarto-table-cell-role="th">nd</th>
<th data-quarto-table-cell-role="th">id</th>
<th data-quarto-table-cell-role="th">sg_number</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">count</td>
<td>294047.000000</td>
<td>294047.000000</td>
<td>294047.000000</td>
<td>294047.000000</td>
<td>294047.000000</td>
<td>294047.000000</td>
<td>294047.000000</td>
<td>294047.000000</td>
<td>2.940470e+05</td>
<td>294047.000000</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">mean</td>
<td>10.880480</td>
<td>12.250730</td>
<td>14.660952</td>
<td>89.810688</td>
<td>95.496771</td>
<td>90.697710</td>
<td>1761.181410</td>
<td>475.436522</td>
<td>4.502841e+06</td>
<td>27.194466</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">std</td>
<td>4.407073</td>
<td>4.930788</td>
<td>5.572797</td>
<td>6.735834</td>
<td>9.633053</td>
<td>8.870661</td>
<td>911.606182</td>
<td>85.121247</td>
<td>2.291774e+06</td>
<td>46.176416</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">min</td>
<td>2.808500</td>
<td>2.825500</td>
<td>2.718100</td>
<td>60.019000</td>
<td>60.130000</td>
<td>60.000000</td>
<td>400.059000</td>
<td>16.000000</td>
<td>1.000000e+06</td>
<td>1.000000</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">25%</td>
<td>8.104550</td>
<td>9.061050</td>
<td>10.951000</td>
<td>90.000000</td>
<td>90.000000</td>
<td>90.000000</td>
<td>1033.725000</td>
<td>498.000000</td>
<td>2.214880e+06</td>
<td>4.000000</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">50%</td>
<td>9.900700</td>
<td>11.252000</td>
<td>13.876500</td>
<td>90.000000</td>
<td>93.612000</td>
<td>90.000000</td>
<td>1587.395000</td>
<td>499.000000</td>
<td>4.122961e+06</td>
<td>14.000000</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">75%</td>
<td>12.467950</td>
<td>14.239950</td>
<td>17.401100</td>
<td>90.000000</td>
<td>101.996000</td>
<td>90.000000</td>
<td>2354.773000</td>
<td>500.000000</td>
<td>7.047926e+06</td>
<td>19.000000</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">max</td>
<td>45.366000</td>
<td>48.809000</td>
<td>49.494500</td>
<td>119.990000</td>
<td>120.000000</td>
<td>120.000000</td>
<td>3999.991000</td>
<td>500.000000</td>
<td>9.016729e+06</td>
<td>230.000000</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>We are down to just shy of 300k samples now, with one last bit of filtering to apply. Lastly, we’ll ensure that we have sufficient easily detectable peaks within our data range. Do to this, we need to look at the intensities:</p>
<div class="cell" data-execution_count="14">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>combined.intensita</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="14">
<pre><code>11        1000.000000,293.781700,0.932900,880.099700,350...
12        344.517500,136.663800,113.543400,41.743900,4.9...
13        480.841100,1000.000000,345.837700,13.887000,72...
14        6.550100,7.094000,99.801200,1000.000000,642.20...
17        2.707700,223.647400,1000.000000,119.345700,113...
                                ...                        
458148    191.292600,19.724900,41.216500,169.019100,150....
458151    1000.000000,782.379000,202.061600,29.027900,13...
458155    1000.000000,62.638200,82.940500,3.929300,0.067...
458158    435.793700,1000.000000,156.773800,74.174400,1....
458159    884.735400,207.638600,175.487800,594.721200,42...
Name: intensita, Length: 294047, dtype: object</code></pre>
</div>
</div>
<p>Intensities are stored as a string of comma separated values, with each pattern scaled to a maximum intensity of 1000. Next we should ensure that in our chosen data range, the intensities that are present are actually strong enough to be observed. Let’s say we want the minimum intensity in our data range to be 0.5 % of the maximum intensity. As such, there should have at least <span class="math inline">\(N\)</span> intensities in our range with a value greater than 5. As discussed earlier, I’ve chosen to set <span class="math inline">\(N = 10\)</span>.</p>
<div class="cell" data-execution_count="15">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> n_peaks_in_range(dspacing, intensity, min_intensity<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    dspacing <span class="op">=</span> <span class="bu">list</span>(<span class="bu">filter</span>(<span class="va">None</span>, dspacing.strip().split(<span class="st">","</span>)))</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    dspacing <span class="op">=</span> np.array([<span class="bu">float</span>(i) <span class="cf">for</span> i <span class="kw">in</span> dspacing])</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    intensity <span class="op">=</span> <span class="bu">list</span>(<span class="bu">filter</span>(<span class="va">None</span>, intensity.strip().split(<span class="st">","</span>)))</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    intensity <span class="op">=</span> np.array([<span class="bu">float</span>(i) <span class="cf">for</span> i <span class="kw">in</span> intensity])</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    intensity <span class="op">=</span> intensity[dspacing <span class="op">&gt;=</span> min_d]</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (intensity <span class="op">&gt;</span> min_intensity).<span class="bu">sum</span>()</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>combined[<span class="st">"n_detectable_peaks_in_range"</span>] <span class="op">=</span> combined.<span class="bu">apply</span>(<span class="kw">lambda</span> x: n_peaks_in_range(x.dvalue, x.intensita), axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>combined[<span class="st">"n_detectable_peaks_in_range"</span>].describe()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="15">
<pre><code>count    294047.000000
mean        113.481430
std          59.305561
min           0.000000
25%          72.000000
50%         107.000000
75%         149.000000
max         386.000000
Name: n_detectable_peaks_in_range, dtype: float64</code></pre>
</div>
</div>
<p>As we can see, some of the patterns we might generate would have very few or no easily detectable peaks in our chosen data range. As our final filtering step, we’ll get rid of them, leaving us with our final filtered dataset.</p>
<div class="cell" data-execution_count="16">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>combined <span class="op">=</span> combined[combined.n_detectable_peaks_in_range <span class="op">&gt;=</span> min_detectable_peaks_in_range]</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>combined.describe()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="16">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">a</th>
<th data-quarto-table-cell-role="th">b</th>
<th data-quarto-table-cell-role="th">c</th>
<th data-quarto-table-cell-role="th">alpha</th>
<th data-quarto-table-cell-role="th">beta</th>
<th data-quarto-table-cell-role="th">gamma</th>
<th data-quarto-table-cell-role="th">volume</th>
<th data-quarto-table-cell-role="th">nd</th>
<th data-quarto-table-cell-role="th">id</th>
<th data-quarto-table-cell-role="th">sg_number</th>
<th data-quarto-table-cell-role="th">n_detectable_peaks_in_range</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">count</td>
<td>288123.000000</td>
<td>288123.000000</td>
<td>288123.000000</td>
<td>288123.000000</td>
<td>288123.000000</td>
<td>288123.000000</td>
<td>288123.000000</td>
<td>288123.000000</td>
<td>2.881230e+05</td>
<td>288123.000000</td>
<td>288123.000000</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">mean</td>
<td>10.915994</td>
<td>12.314144</td>
<td>14.769507</td>
<td>89.806797</td>
<td>95.609645</td>
<td>90.698470</td>
<td>1780.427861</td>
<td>484.062508</td>
<td>4.493060e+06</td>
<td>23.272384</td>
<td>115.697018</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">std</td>
<td>4.439603</td>
<td>4.955456</td>
<td>5.568620</td>
<td>6.804673</td>
<td>9.698929</td>
<td>8.939179</td>
<td>909.067811</td>
<td>60.494039</td>
<td>2.259233e+06</td>
<td>37.387276</td>
<td>57.842270</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">min</td>
<td>2.808500</td>
<td>2.825500</td>
<td>2.760000</td>
<td>60.019000</td>
<td>60.130000</td>
<td>60.000000</td>
<td>400.059000</td>
<td>30.000000</td>
<td>1.000000e+06</td>
<td>1.000000</td>
<td>10.000000</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">25%</td>
<td>8.099250</td>
<td>9.133100</td>
<td>11.122850</td>
<td>90.000000</td>
<td>90.000000</td>
<td>90.000000</td>
<td>1054.453000</td>
<td>498.000000</td>
<td>2.216278e+06</td>
<td>4.000000</td>
<td>75.000000</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">50%</td>
<td>9.925000</td>
<td>11.332000</td>
<td>13.984900</td>
<td>90.000000</td>
<td>93.924000</td>
<td>90.000000</td>
<td>1608.534000</td>
<td>499.000000</td>
<td>4.122969e+06</td>
<td>14.000000</td>
<td>108.000000</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">75%</td>
<td>12.542100</td>
<td>14.337000</td>
<td>17.492400</td>
<td>90.000000</td>
<td>102.190000</td>
<td>90.000000</td>
<td>2378.520500</td>
<td>500.000000</td>
<td>7.045938e+06</td>
<td>15.000000</td>
<td>151.000000</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">max</td>
<td>45.366000</td>
<td>48.809000</td>
<td>49.494500</td>
<td>119.990000</td>
<td>120.000000</td>
<td>120.000000</td>
<td>3999.991000</td>
<td>500.000000</td>
<td>9.016729e+06</td>
<td>230.000000</td>
<td>386.000000</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</section>
<section id="saving-the-filtered-data" class="level3">
<h3 class="anchored" data-anchor-id="saving-the-filtered-data">Saving the filtered data</h3>
<p>Now that we’ve filtered our data to our requirements, the last thing to do is save the relevant information in numpy arrays which can then be quickly and easily loaded from disk when needed.</p>
<p>The arrays to be saved will contain:</p>
<ul>
<li>Unit cells</li>
<li>Crystal systems</li>
<li>Miller indices</li>
<li>Peak intensities</li>
<li>Space groups</li>
<li>COD IDs in case we want to look up a particular crystal structure</li>
</ul>
<p>As the number of peaks in each pattern is different, the Miller indices and Peak intensity arrays will need padding up to the maximum number, which is 500.</p>
<div class="cell" data-execution_count="18">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_array(x, dtype<span class="op">=</span>np.float32):</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> np.zeros(<span class="dv">500</span>, dtype<span class="op">=</span>dtype)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="bu">list</span>(<span class="bu">filter</span>(<span class="va">None</span>, x.strip().split(<span class="st">","</span>)))</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.array(x, dtype<span class="op">=</span>dtype)</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    data[:<span class="bu">len</span>(x)] <span class="op">=</span> x</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> data</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> combined.h.<span class="bu">apply</span>(get_array, args<span class="op">=</span>(np.int64,))</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> combined.k.<span class="bu">apply</span>(get_array, args<span class="op">=</span>(np.int64,))</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>l <span class="op">=</span> combined.l.<span class="bu">apply</span>(get_array, args<span class="op">=</span>(np.int64,))</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>intensities <span class="op">=</span> combined.intensita.<span class="bu">apply</span>(get_array, args<span class="op">=</span>(np.float32,))</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>intensities <span class="op">=</span> np.vstack(intensities)</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> np.vstack(h)</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> np.vstack(k)</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>l <span class="op">=</span> np.vstack(l)</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>hkl <span class="op">=</span> np.dstack([h,k,l])</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>unit_cell <span class="op">=</span> combined[[<span class="st">"a"</span>,<span class="st">"b"</span>,<span class="st">"c"</span>,<span class="st">"alpha"</span>,<span class="st">"beta"</span>,<span class="st">"gamma"</span>]].to_numpy()</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>crystal_systems, crystal_systems_numeric <span class="op">=</span> np.unique(combined.<span class="bu">type</span>.to_numpy(), return_inverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>space_group_number <span class="op">=</span> combined.sg_number.to_numpy()</span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>cod_id <span class="op">=</span> combined.<span class="bu">id</span>.to_numpy()</span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(crystal_systems)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Now we can save everything, as well as a configuration file to keep track of our settings, which we’ll save using the <code>json</code> format.</p>
<div class="cell" data-execution_count="19">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> json</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>base_name <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span>min_data_angle<span class="sc">}</span><span class="ss">-</span><span class="sc">{</span>max_data_angle<span class="sc">}</span><span class="ss">-CuKa1-data_</span><span class="sc">{</span>max_volume<span class="sc">}</span><span class="ss">_"</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>config <span class="op">=</span> {}</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>config[<span class="st">"base_name"</span>] <span class="op">=</span> base_name</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>config[<span class="st">"min_volume"</span>] <span class="op">=</span> min_volume</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>config[<span class="st">"max_volume"</span>] <span class="op">=</span> max_volume</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>config[<span class="st">"max_cell_length"</span>] <span class="op">=</span> max_cell_length</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>config[<span class="st">"min_cell_angle"</span>] <span class="op">=</span> min_cell_angle</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>config[<span class="st">"max_cell_angle"</span>] <span class="op">=</span> max_cell_angle</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>config[<span class="st">"min_data_angle"</span>] <span class="op">=</span> min_data_angle</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>config[<span class="st">"max_data_angle"</span>] <span class="op">=</span> max_data_angle</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>config[<span class="st">"wavelength"</span>] <span class="op">=</span> wavelength</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>config[<span class="st">"min_detectable_peaks_in_range"</span>] <span class="op">=</span> min_detectable_peaks_in_range</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>config[<span class="st">"crystal_systems"</span>] <span class="op">=</span> [x[<span class="dv">0</span>]<span class="op">+</span><span class="st">" = "</span><span class="op">+</span><span class="bu">str</span>(x[<span class="dv">1</span>]) <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">zip</span>(crystal_systems, np.arange(<span class="bu">len</span>(crystal_systems)))]</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="st">"data_config.json"</span>, <span class="st">"w"</span>) <span class="im">as</span> f:</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>    json.dump(config, f, indent<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>np.save(base_name<span class="op">+</span><span class="st">"unit_cell.npy"</span>, unit_cell)</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>np.save(base_name<span class="op">+</span><span class="st">"crystal_systems_numeric.npy"</span>, crystal_systems_numeric)</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>np.save(base_name<span class="op">+</span><span class="st">"space_group_number.npy"</span>, space_group_number)</span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>np.save(base_name<span class="op">+</span><span class="st">"hkl.npy"</span>, hkl)</span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>np.save(base_name<span class="op">+</span><span class="st">"intensities.npy"</span>, intensities)</span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>np.save(base_name<span class="op">+</span><span class="st">"cod_id.npy"</span>, cod_id)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
</section>
<section id="generating-synthetic-data" class="level1">
<h1>Generating synthetic data</h1>
<p>Now that we’ve filtered down the original PowCod database into the entries that meet the (arbitrary) conditions described earlier, it’s time to start thinking about how we can use the information to generate synthetic PXRD data.</p>
<p>I’ve split this task into:</p>
<ul>
<li>Peak positions</li>
<li>Peak intensities</li>
<li>Peak shapes</li>
<li>Noise and background</li>
</ul>
<section id="peak-positions" class="level2">
<h2 class="anchored" data-anchor-id="peak-positions">Peak positions</h2>
<p>Rather than using the d-spacings from the database directly, we are going to make use of the unit cells and Miller indices to calculate the d-spacings (and hence angles) for the reflections. This will allow us to add a small amount of noise to the unit cell dimensions, which serves as a form of data augmentation.</p>
<p>The d-spacing of a given reflection can be calculated using this equation:</p>
<p><span class="math inline">\(\frac{1}{d^{2}} = X_{hh}h^2 + X_{kk}k^2 + X_{ll}l^2 + X_{hk}hk +X_{hl}hl + X_{kl}kl\)</span></p>
<p>where <span class="math inline">\(X_{nn}\)</span> are elements of the reciprocal space metric tensor.</p>
<p>This means that we will need a function to convert the unit cell dimensions into a matrix representation of the unit cell, invert this to determine the reciprocal lattice matrix and from this obtain the reciprocal lattice metric tensor. Once we have the reciprocal lattice metric tensor, we can calculate the d-spacings quite easily by multiplying with the Miller index array(s). However, one complication is that we want to do this for several samples simultaneously, so need to consider the shapes of our arrays.</p>
<p>Before dealing with that, let’s write a function to simulate the effect of temperature changes, by adding a small amount of Gaussian noise to the unit cell dimensions. We will have to consider the crystal system symmetry here in order to ensure that, for example a cubic unit cell, the perturbation to lengths <span class="math inline">\(b\)</span> and <span class="math inline">\(c\)</span> is equal to the pertubation to <span class="math inline">\(a\)</span>. The standard deviation of the random noise to be added is going to be set to a default value of 0.05, meaning that the majority of perturbed unit cells should have edges with lengths +/- 0.15 Å from the database values, and angles +/- 0.15 ° (assuming they are allowed to vary by symmetry). This seems reasonable, and should allow us to assume that the fractional coordinates within the unit cells are unaffected, so we don’t need to worry about the effect on the relative intensities.</p>
<div class="cell" data-execution_count="14">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_unit_cell_perturbation(crystal_systems, dtype<span class="op">=</span>torch.float32, stddev<span class="op">=</span><span class="fl">0.05</span>):</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Generate a perturbation for the unit cell lengths and angles for a given</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="co">    crystal system.</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="co">        crystal_systems (tensor):   Crystal systems for the unit cells.</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a><span class="co">                                    Shape = (batch)</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a><span class="co">        dtype (torch.dtype, optional): Defaults to torch.float32.</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a><span class="co">        stddev (float, optional):   Standard deviation for the gaussian noise.</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a><span class="co">                                    Defaults to 0.05.</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a><span class="co">        tensor: A tensors to additively adjust the unit cell lengths and angles</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a><span class="co">                Shape = (batch, 6)</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>    batchsize <span class="op">=</span> crystal_systems.shape[<span class="dv">0</span>]</span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>    device <span class="op">=</span> crystal_systems.device</span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>    lengths, angles <span class="op">=</span> torch.randn((<span class="dv">2</span>, batchsize, <span class="dv">3</span>), device<span class="op">=</span>device, dtype<span class="op">=</span>dtype) <span class="op">*</span> stddev</span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>    cubic <span class="op">=</span> crystal_systems <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>    hexagonal <span class="op">=</span> crystal_systems <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a>    monoclinic <span class="op">=</span> crystal_systems <span class="op">==</span> <span class="dv">2</span></span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">#orthorhombic = crystal_systems == 3 # Don't need to query data for this</span></span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a>    tetragonal <span class="op">=</span> crystal_systems <span class="op">==</span> <span class="dv">4</span></span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a>    triclinic <span class="op">=</span> crystal_systems <span class="op">==</span> <span class="dv">5</span></span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a>    trigonal_h <span class="op">=</span> crystal_systems <span class="op">==</span> <span class="dv">6</span></span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a>    trigonal_r <span class="op">=</span> crystal_systems <span class="op">==</span> <span class="dv">7</span></span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Cubic, tetragonal, rhombohedral and hexagonal - a and b must be the same</span></span>
<span id="cb23-31"><a href="#cb23-31" aria-hidden="true" tabindex="-1"></a>    lengths[:,<span class="dv">1</span>] <span class="op">=</span> torch.where(cubic <span class="op">|</span> hexagonal <span class="op">|</span> tetragonal <span class="op">|</span> trigonal_h <span class="op">|</span> trigonal_r,</span>
<span id="cb23-32"><a href="#cb23-32" aria-hidden="true" tabindex="-1"></a>                            lengths[:,<span class="dv">0</span>], lengths[:,<span class="dv">1</span>])</span>
<span id="cb23-33"><a href="#cb23-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Cubic and rhombohedral cells - a, b and c must be the same</span></span>
<span id="cb23-34"><a href="#cb23-34" aria-hidden="true" tabindex="-1"></a>    lengths[:,<span class="dv">2</span>] <span class="op">=</span> torch.where(cubic <span class="op">|</span> trigonal_r, lengths[:,<span class="dv">0</span>], lengths[:,<span class="dv">2</span>])</span>
<span id="cb23-35"><a href="#cb23-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Rhombohedral and triclinic cells - could change their alpha values</span></span>
<span id="cb23-36"><a href="#cb23-36" aria-hidden="true" tabindex="-1"></a>    angles[:,<span class="dv">0</span>] <span class="op">=</span> torch.where((trigonal_r <span class="op">|</span> triclinic), angles[:,<span class="dv">0</span>], <span class="fl">0.</span>)</span>
<span id="cb23-37"><a href="#cb23-37" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Triclinic or monoclinic cells could change beta values</span></span>
<span id="cb23-38"><a href="#cb23-38" aria-hidden="true" tabindex="-1"></a>    angles[:,<span class="dv">1</span>] <span class="op">=</span> torch.where((triclinic <span class="op">|</span> monoclinic), angles[:,<span class="dv">1</span>], <span class="fl">0.</span>)</span>
<span id="cb23-39"><a href="#cb23-39" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Triclinc cells could change gamma</span></span>
<span id="cb23-40"><a href="#cb23-40" aria-hidden="true" tabindex="-1"></a>    angles[:,<span class="dv">2</span>] <span class="op">=</span> torch.where(triclinic, angles[:,<span class="dv">2</span>], <span class="fl">0.</span>)</span>
<span id="cb23-41"><a href="#cb23-41" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Rhombohedral cells - need to ensure all angles are the same</span></span>
<span id="cb23-42"><a href="#cb23-42" aria-hidden="true" tabindex="-1"></a>    angles[:,<span class="dv">1</span>] <span class="op">=</span> torch.where(trigonal_r, angles[:,<span class="dv">0</span>], angles[:,<span class="dv">1</span>])</span>
<span id="cb23-43"><a href="#cb23-43" aria-hidden="true" tabindex="-1"></a>    angles[:,<span class="dv">2</span>] <span class="op">=</span> torch.where(trigonal_r, angles[:,<span class="dv">0</span>], angles[:,<span class="dv">2</span>])</span>
<span id="cb23-44"><a href="#cb23-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-45"><a href="#cb23-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> torch.concat([lengths, angles], dim<span class="op">=-</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Let’s check it does what it’s meant to!</p>
<p>What we’re expecting is that for the unit cell lengths, the perturbation should be the same for each of the edges for cubic and rhombohedral cells, and the perturbation for <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> should be the same for hexagonal and tetragonal cells.</p>
<p>With regards to angles, where the original unit cell is an angle of 90 or 120 degrees, the perturbation should be zero. So we should see a change in the beta value for monoclinic cells, a change for all values of the triclinic unit cells and the same change for each of the angles for rhombohedral cells.</p>
<div class="cell" data-execution_count="15">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>cs_key <span class="op">=</span>  {</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Cubic"</span> : <span class="dv">0</span>,</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Hexagonal"</span> :  <span class="dv">1</span>,</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Monoclinic"</span> : <span class="dv">2</span>,</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Orthorhombic"</span> : <span class="dv">3</span>,</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Tetragonal"</span> : <span class="dv">4</span>,</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Triclinic"</span> : <span class="dv">5</span>,</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Trigonal (hexagonal axes)"</span> : <span class="dv">6</span>,</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Trigonal (rhombohedral axes)"</span> : <span class="dv">7</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> c <span class="kw">in</span> cs_key.items():</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>    name, number <span class="op">=</span> c</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>    perturb <span class="op">=</span> get_unit_cell_perturbation(torch.tensor([[<span class="bu">int</span>(number)]]))</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>    lengths <span class="op">=</span> perturb[:,:<span class="dv">3</span>]</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>    angles <span class="op">=</span> perturb[:,<span class="dv">3</span>:]</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(name, <span class="st">"Length perturbation:"</span>, lengths)</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(name, <span class="st">"Angle perturbation:"</span>, angles,<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Cubic Length perturbation: tensor([[0.0120, 0.0120, 0.0120]])
Cubic Angle perturbation: tensor([[0., 0., 0.]]) 

Hexagonal Length perturbation: tensor([[0.0535, 0.0535, 0.0225]])
Hexagonal Angle perturbation: tensor([[0., 0., 0.]]) 

Monoclinic Length perturbation: tensor([[-0.0509,  0.0907, -0.0980]])
Monoclinic Angle perturbation: tensor([[0.0000, 0.0176, 0.0000]]) 

Orthorhombic Length perturbation: tensor([[-0.0788, -0.0403, -0.0860]])
Orthorhombic Angle perturbation: tensor([[0., 0., 0.]]) 

Tetragonal Length perturbation: tensor([[-0.0156, -0.0156, -0.0144]])
Tetragonal Angle perturbation: tensor([[0., 0., 0.]]) 

Triclinic Length perturbation: tensor([[-0.0154, -0.0387,  0.0159]])
Triclinic Angle perturbation: tensor([[ 0.0273, -0.0582, -0.0836]]) 

Trigonal (hexagonal axes) Length perturbation: tensor([[-0.0063, -0.0063,  0.0845]])
Trigonal (hexagonal axes) Angle perturbation: tensor([[0., 0., 0.]]) 

Trigonal (rhombohedral axes) Length perturbation: tensor([[-0.0002, -0.0002, -0.0002]])
Trigonal (rhombohedral axes) Angle perturbation: tensor([[-0.0607, -0.0607, -0.0607]]) 
</code></pre>
</div>
</div>
<p>Looks good to me. We now need to start writing functions to generate our lattice matrix, reciprocal lattice matrix and reciprocal lattice metric tensor. We can then use these in conjunction with the Miller indices to determine the reflection d-spacings.</p>
<p>Given that we are modifying unit cells, it’s probably sensible to check that the perturbed unit cells are valid. We can do that by calculating the volume of the unit cells, with invalid unit cells returning a volume of zero.</p>
<div class="cell" data-execution_count="16">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_lattice_matrix(unit_cell_dimensions):</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""calculate a lattice matrix from unit cell dimensions</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="co">        unit_cell_dimensions (tensor):  The unit cell dimensions. Lengths in</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="co">                                        angstroms, angles in degrees.</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="co">                                        Shape = (batch, 6)</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a><span class="co">        tensor: The matrix representation of the unit cells.</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a><span class="co">                Shape = (batch, 3, 3)</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>    pi_over_180<span class="op">=</span><span class="fl">0.017453292519943295</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>    a, b, c <span class="op">=</span> unit_cell_dimensions[:,:<span class="dv">3</span>].T</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>    cosal, cosbe, cosga <span class="op">=</span> torch.cos(unit_cell_dimensions[:,<span class="dv">3</span>:]<span class="op">*</span>pi_over_180).T</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>    sinal, sinbe <span class="op">=</span> torch.sin(unit_cell_dimensions[:,<span class="dv">3</span>:<span class="op">-</span><span class="dv">1</span>]<span class="op">*</span>pi_over_180).T</span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sometimes rounding errors cause |values| slightly &gt; 1.</span></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>    val <span class="op">=</span> torch.clamp((cosal <span class="op">*</span> cosbe <span class="op">-</span> cosga) <span class="op">/</span> (sinal <span class="op">*</span> sinbe), <span class="bu">min</span><span class="op">=-</span><span class="dv">1</span>, <span class="bu">max</span><span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>    gamma_star <span class="op">=</span> torch.arccos(val)</span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>    zeros <span class="op">=</span> torch.zeros_like(a)</span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a>    v_a <span class="op">=</span> torch.stack([a <span class="op">*</span> sinbe, zeros, a<span class="op">*</span>cosbe]).T</span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a>    v_b <span class="op">=</span> torch.stack([<span class="op">-</span>b <span class="op">*</span> sinal <span class="op">*</span> torch.cos(gamma_star),</span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a>                    b<span class="op">*</span>sinal <span class="op">*</span> torch.sin(gamma_star),</span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a>                    b<span class="op">*</span>cosal]).T</span>
<span id="cb26-26"><a href="#cb26-26" aria-hidden="true" tabindex="-1"></a>    v_c <span class="op">=</span> torch.stack([zeros, zeros, c]).T</span>
<span id="cb26-27"><a href="#cb26-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-28"><a href="#cb26-28" aria-hidden="true" tabindex="-1"></a>    matrix <span class="op">=</span> torch.stack([v_a,v_b,v_c], dim<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb26-29"><a href="#cb26-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-30"><a href="#cb26-30" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Unit cells are valid if cell volume &gt; 0</span></span>
<span id="cb26-31"><a href="#cb26-31" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The cell volume is |det(M)|, but don't need the absolute value here</span></span>
<span id="cb26-32"><a href="#cb26-32" aria-hidden="true" tabindex="-1"></a>    volume <span class="op">=</span> torch.linalg.det(matrix)</span>
<span id="cb26-33"><a href="#cb26-33" aria-hidden="true" tabindex="-1"></a>    valid <span class="op">=</span> volume <span class="op">!=</span> <span class="dv">0</span></span>
<span id="cb26-34"><a href="#cb26-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-35"><a href="#cb26-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> matrix, valid</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Let’s quickly check that this works as expected. I’ll give it a simple cubic unit cell, and an invalid unit cell.</p>
<div class="cell" data-execution_count="17">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>cubic_cell <span class="op">=</span> torch.tensor([<span class="fl">5.0</span>, <span class="fl">5.0</span>, <span class="fl">5.0</span>, <span class="fl">90.0</span>, <span class="fl">90.0</span>, <span class="fl">90.0</span>]).unsqueeze(<span class="dv">0</span>)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>invalid_cell <span class="op">=</span> torch.tensor([<span class="fl">5.0</span>, <span class="fl">6.0</span>, <span class="fl">7.0</span>, <span class="fl">120.0</span>, <span class="fl">120.0</span>, <span class="fl">120.0</span>]).unsqueeze(<span class="dv">0</span>)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Cubic cell valid -"</span>,get_lattice_matrix(cubic_cell)[<span class="dv">1</span>].item())</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Invalid cell valid -"</span>, get_lattice_matrix(invalid_cell)[<span class="dv">1</span>].item())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Cubic cell valid - True
Invalid cell valid - False</code></pre>
</div>
</div>
<p>The last couple of functions we need to implement then include a way to get the reciprocal lattice metric tensor. The reciprocal lattice matrix can be easily obtained by inverting the lattice matrix we calculated previously.</p>
<p>We also need a way to obtain the reflection d-spacings, and then lastly convert the d-spacings to <span class="math inline">\(2\theta\)</span>.</p>
<div class="cell" data-execution_count="18">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_recip_lattice_metric_tensor(recip_lattice_matrix):</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Calculate the reciprocal lattice metric tensor</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="co">        recip_lattice_matrix (tensor):  Reciprocal lattice matrix</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="co">                                        Shape = (batch, 3, 3)</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a><span class="co">        tensor: Reciprocal lattice metric tensor</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a><span class="co">                Shape = (batch, 3, 3)</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> recip_lattice_matrix <span class="op">@</span> recip_lattice_matrix.permute(<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">1</span>)</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_d_spacing(recip_latt_metric_tensor,hkl):</span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Calculate the d-spacings for the reflections from the Miller indices and</span></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a><span class="co">    the reciprocal lattice metric tensor</span></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a><span class="co">        recip_latt_metric_tensor (tensor):  Reciprocal lattice metric tensor</span></span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a><span class="co">                                            Shape = (batch, 3, 3)</span></span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a><span class="co">        hkl (tensor):   Miller indices</span></span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a><span class="co">                        Shape = (batch, number of reflections, 3)</span></span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-25"><a href="#cb29-25" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb29-26"><a href="#cb29-26" aria-hidden="true" tabindex="-1"></a><span class="co">        tensor: d-spacing for each of the reflections</span></span>
<span id="cb29-27"><a href="#cb29-27" aria-hidden="true" tabindex="-1"></a><span class="co">                Shape = (batch, number of reflections)</span></span>
<span id="cb29-28"><a href="#cb29-28" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb29-29"><a href="#cb29-29" aria-hidden="true" tabindex="-1"></a>    one_over_d_squared <span class="op">=</span> torch.einsum(<span class="st">"bij,bji-&gt;bi"</span>,hkl,torch.einsum(</span>
<span id="cb29-30"><a href="#cb29-30" aria-hidden="true" tabindex="-1"></a>                                <span class="st">"bij,bkj-&gt;bik"</span>,recip_latt_metric_tensor,hkl))</span>
<span id="cb29-31"><a href="#cb29-31" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>torch.sqrt(one_over_d_squared)</span>
<span id="cb29-32"><a href="#cb29-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> d</span>
<span id="cb29-33"><a href="#cb29-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-34"><a href="#cb29-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-35"><a href="#cb29-35" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> d_to_tt(d,wavelength<span class="op">=</span><span class="fl">1.54056</span>):</span>
<span id="cb29-36"><a href="#cb29-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Convert d-spacings to twotheta values (in degrees)</span></span>
<span id="cb29-37"><a href="#cb29-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-38"><a href="#cb29-38" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb29-39"><a href="#cb29-39" aria-hidden="true" tabindex="-1"></a><span class="co">        d (tensor): d-spacings for each of the reflections</span></span>
<span id="cb29-40"><a href="#cb29-40" aria-hidden="true" tabindex="-1"></a><span class="co">                    Shape = (batch, number of reflections)</span></span>
<span id="cb29-41"><a href="#cb29-41" aria-hidden="true" tabindex="-1"></a><span class="co">        wavelength (float): The wavelength of the radiation. Defaults to</span></span>
<span id="cb29-42"><a href="#cb29-42" aria-hidden="true" tabindex="-1"></a><span class="co">                            1.54056 which is copper K-a1</span></span>
<span id="cb29-43"><a href="#cb29-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-44"><a href="#cb29-44" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb29-45"><a href="#cb29-45" aria-hidden="true" tabindex="-1"></a><span class="co">        tensor: twotheta values for each of the reflections</span></span>
<span id="cb29-46"><a href="#cb29-46" aria-hidden="true" tabindex="-1"></a><span class="co">                Shape = (batch, number of reflections)</span></span>
<span id="cb29-47"><a href="#cb29-47" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb29-48"><a href="#cb29-48" aria-hidden="true" tabindex="-1"></a>    two_times_180_over_pi <span class="op">=</span> <span class="fl">114.59155902616465</span></span>
<span id="cb29-49"><a href="#cb29-49" aria-hidden="true" tabindex="-1"></a>    tt <span class="op">=</span> two_times_180_over_pi<span class="op">*</span>torch.arcsin(wavelength<span class="op">/</span>(<span class="dv">2</span><span class="op">*</span>d))</span>
<span id="cb29-50"><a href="#cb29-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> tt</span>
<span id="cb29-51"><a href="#cb29-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-52"><a href="#cb29-52" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_zero_point_error(batchsize, device, dtype, zpemin<span class="op">=</span><span class="fl">0.03</span>, zpemax<span class="op">=</span><span class="fl">0.03</span>):</span>
<span id="cb29-53"><a href="#cb29-53" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb29-54"><a href="#cb29-54" aria-hidden="true" tabindex="-1"></a><span class="co">    Generate a random zero-point error to be applied to the peak positions</span></span>
<span id="cb29-55"><a href="#cb29-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-56"><a href="#cb29-56" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb29-57"><a href="#cb29-57" aria-hidden="true" tabindex="-1"></a><span class="co">        batchsize (int): Size of the batch dimension</span></span>
<span id="cb29-58"><a href="#cb29-58" aria-hidden="true" tabindex="-1"></a><span class="co">        device (torch.device): Device to generate the tensor on</span></span>
<span id="cb29-59"><a href="#cb29-59" aria-hidden="true" tabindex="-1"></a><span class="co">        dtype (torch.dtype): dtype to use for the ZPEs</span></span>
<span id="cb29-60"><a href="#cb29-60" aria-hidden="true" tabindex="-1"></a><span class="co">        zpemin (float, optional): Lower bound for zero point error in degrees</span></span>
<span id="cb29-61"><a href="#cb29-61" aria-hidden="true" tabindex="-1"></a><span class="co">        zpemax (float, optional): Upper bound for zero point error in degrees</span></span>
<span id="cb29-62"><a href="#cb29-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-63"><a href="#cb29-63" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb29-64"><a href="#cb29-64" aria-hidden="true" tabindex="-1"></a><span class="co">        tensor: Zero point error to be applied to the peak positions</span></span>
<span id="cb29-65"><a href="#cb29-65" aria-hidden="true" tabindex="-1"></a><span class="co">                Shape = (batch, 1)</span></span>
<span id="cb29-66"><a href="#cb29-66" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb29-67"><a href="#cb29-67" aria-hidden="true" tabindex="-1"></a>    zero_point_error <span class="op">=</span> (torch.rand((batchsize,<span class="dv">1</span>), device<span class="op">=</span>device, dtype<span class="op">=</span>dtype)</span>
<span id="cb29-68"><a href="#cb29-68" aria-hidden="true" tabindex="-1"></a>                        <span class="op">*</span> (zpemax <span class="op">-</span> zpemin)) <span class="op">+</span> zpemin</span>
<span id="cb29-69"><a href="#cb29-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> zero_point_error</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>To test the whole set of functions written so far, I’ll add a convenience function to calculate the peak positions from the unit cells and Miller indices.</p>
<div class="cell" data-execution_count="19">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_peak_positions(unit_cells, hkl, zpe<span class="op">=</span><span class="va">True</span>, wavelength<span class="op">=</span><span class="fl">1.54056</span>):</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    lattice_matrix, valid <span class="op">=</span> get_lattice_matrix(unit_cells)</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    unit_cells <span class="op">=</span> unit_cells[valid]</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    hkl <span class="op">=</span> hkl[valid]</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    reciprocal_lattice_matrix <span class="op">=</span> torch.linalg.inv(lattice_matrix)</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    reciprocal_lattice_metric_tensor <span class="op">=</span> get_recip_lattice_metric_tensor(reciprocal_lattice_matrix)</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    d_spacing <span class="op">=</span> get_d_spacing(reciprocal_lattice_metric_tensor, hkl)</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>    twotheta <span class="op">=</span> d_to_tt(d_spacing, wavelength)</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> zpe:</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>        zero_point_error <span class="op">=</span> get_zero_point_error(twotheta.shape[<span class="dv">0</span>],</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>                                                twotheta.device,</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>                                                twotheta.dtype)</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>        twotheta <span class="op">+=</span> zero_point_error</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> twotheta</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>I’ll test that using some diffraction data for a <a href="https://www.mdpi.com/2073-4352/10/1/42">Carbamazepine:Indomethacin cocrystal</a> I published a while ago. The first 3 peaks have the following Miller indices and positions:</p>
<table class="table">
<thead>
<tr class="header">
<th><span class="math inline">\(h\)</span></th>
<th><span class="math inline">\(k\)</span></th>
<th><span class="math inline">\(l\)</span></th>
<th><span class="math inline">\(2\theta\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>1</td>
<td>0</td>
<td>5.322</td>
</tr>
<tr class="even">
<td>2</td>
<td>0</td>
<td>0</td>
<td>7.496</td>
</tr>
<tr class="odd">
<td>0</td>
<td>2</td>
<td>0</td>
<td>7.562</td>
</tr>
</tbody>
</table>
<p>And the unit cell is:</p>
<p><span class="math inline">\(a\)</span> = 23.573194, <span class="math inline">\(b\)</span> = 23.363375, <span class="math inline">\(c\)</span> = 5.125218</p>
<p><span class="math inline">\(\alpha\)</span> = 90.000, <span class="math inline">\(\beta\)</span> = 88.77132, <span class="math inline">\(\gamma\)</span> = 90.000</p>
<p>We’ll run the function both with and without zero point errors applied.</p>
<div class="cell" data-execution_count="20">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>coXtal_unit_cell <span class="op">=</span> torch.tensor([<span class="fl">23.573194</span>, <span class="fl">23.363375</span>, <span class="fl">5.125218</span>, <span class="fl">90.000</span>, <span class="fl">88.77132</span>, <span class="fl">90.000</span>])</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>coXtal_hkl <span class="op">=</span> torch.tensor([[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>],[<span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">0</span>]]).<span class="bu">float</span>()</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> zpe <span class="kw">in</span> [<span class="va">False</span>, <span class="va">True</span>]:</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"ZPE:"</span>,zpe)</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    coXtal_twotheta <span class="op">=</span> get_peak_positions(coXtal_unit_cell.reshape(<span class="dv">1</span>,<span class="dv">6</span>), coXtal_hkl.reshape(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">3</span>), zpe<span class="op">=</span>zpe)</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"[h, k, l]  2θ"</span>)</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"----------------"</span>)</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, ht <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(coXtal_hkl, coXtal_twotheta.squeeze())):</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(ht[<span class="dv">0</span>].<span class="bu">int</span>().tolist(), <span class="ss">f"</span><span class="sc">{</span>ht[<span class="dv">1</span>]<span class="sc">.</span>item()<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">""</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>ZPE: False
[h, k, l]  2θ
----------------
[1, 1, 0] 5.322
[2, 0, 0] 7.496
[0, 2, 0] 7.562

ZPE: True
[h, k, l]  2θ
----------------
[1, 1, 0] 5.352
[2, 0, 0] 7.526
[0, 2, 0] 7.592
</code></pre>
</div>
</div>
<p>That looks like it’s working nicely - without a zero point error, the peak positions match, whilst with an error, the peak positions are all shifted by a consistent amount.</p>
</section>
<section id="peak-intensities" class="level2">
<h2 class="anchored" data-anchor-id="peak-intensities">Peak intensities</h2>
<p>The main contribution to the intensity of a diffraction peak is the position of the atoms within the unit cell. What makes the PowCod database so helpful is that this has already been calculated, and can be read in from the intensities array we saved earlier.</p>
<p>However, there are experimental/physical effects that can modulate these intensities. Most import is the effect of preferred orientation. There are several ways to model this, I’m choosing to implement the <a href="https://scripts.iucr.org/cgi-bin/paper?a26366">March-Dollase</a> method as I already have some code written to do this in <em>GALLOP</em>. This code is actually based on code from GSAS-II; see the <code>GetPrefOri</code> function in the file found <a href="https://subversion.xray.aps.anl.gov/pyGSAS/trunk/GSASIIstrMath.py">here</a>. I updated it to use pytorch, and work over a batch of multiple PXRD patterns.</p>
<p>Again, this is being implemented as a form of data augmentation, allowing our existing data to generate multiple different, but plausible, diffraction patterns. As such, the preferred orientation axis is limited to being in the [1,0,0], [0,1,0] or [0,0,1] directions.</p>
<p>Future work could extend this to use the more sophisticated spherical harmonic approach described <a href="http://scripts.iucr.org/cgi-bin/paper?S0021889897005918">here</a>.</p>
<div class="cell" data-execution_count="21">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_MD_PO_components(hkl, reciprocal_lattice_metric_tensor, dspacing, factor_std<span class="op">=</span><span class="fl">0.1</span>):</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Calculate the terms needed in the March-Dollase preferred orientation</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="co">    correction.</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="co">        hkl (tensor):   The Miller indices of the reflections.</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="co">                        Shape = (batch, number of reflections, 3)</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a><span class="co">        reciprocal_lattice_matrix (tensor): The reciprocal lattice matrix</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a><span class="co">                                            Shape = (batch, 3, 3)</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a><span class="co">        factor_std (float, optional):   The standard deviation for the normally</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a><span class="co">                                        distributed March-Dollase factors.</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a><span class="co">                                        Defaults to 0.1.</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a><span class="co">        tuple: Tuple of tensors containing the terms needed in the March-Dollase</span></span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a><span class="co">        preferred orientation correction function. cosP, sinP = cosine and sine</span></span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a><span class="co">        of the angle between the Miller indices and the PO axis. Factor = the</span></span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a><span class="co">        March Dollase factors, PO_axis = the preferred orientation axis.</span></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a>    batchsize <span class="op">=</span> hkl.shape[<span class="dv">0</span>]</span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a>    device <span class="op">=</span> hkl.device</span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a>    dtype <span class="op">=</span> hkl.dtype</span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Randomly assign the PO axis to be either [1,0,0], [0,1,0] or [0,0,1]</span></span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true" tabindex="-1"></a>    PO_axis <span class="op">=</span> torch.zeros((batchsize, <span class="dv">3</span>), device<span class="op">=</span>device, dtype<span class="op">=</span>dtype)</span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true" tabindex="-1"></a>    PO_axis_select <span class="op">=</span> torch.randint(<span class="dv">0</span>,<span class="dv">3</span>,(batchsize,),device<span class="op">=</span>device)</span>
<span id="cb33-26"><a href="#cb33-26" aria-hidden="true" tabindex="-1"></a>    PO_axis[torch.arange(batchsize, device<span class="op">=</span>device),PO_axis_select] <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb33-27"><a href="#cb33-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-28"><a href="#cb33-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-29"><a href="#cb33-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""u = hkl / torch.sqrt(torch.einsum("bkj,bkj-&gt;bk", hkl,</span></span>
<span id="cb33-30"><a href="#cb33-30" aria-hidden="true" tabindex="-1"></a><span class="co">                        torch.einsum("bij,bkj-&gt;bki",</span></span>
<span id="cb33-31"><a href="#cb33-31" aria-hidden="true" tabindex="-1"></a><span class="co">                        reciprocal_lattice_matrix,hkl))).unsqueeze(2)"""</span></span>
<span id="cb33-32"><a href="#cb33-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Dividing the Miller indices by the reciprocal lattice vector lengths is</span></span>
<span id="cb33-33"><a href="#cb33-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># equivalent to multiplying them by the d-spacings</span></span>
<span id="cb33-34"><a href="#cb33-34" aria-hidden="true" tabindex="-1"></a>    u <span class="op">=</span> hkl <span class="op">*</span> dspacing.unsqueeze(<span class="dv">2</span>)</span>
<span id="cb33-35"><a href="#cb33-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-36"><a href="#cb33-36" aria-hidden="true" tabindex="-1"></a>    cosP <span class="op">=</span> torch.einsum(<span class="st">"bij,bj-&gt;bi"</span>, u, torch.einsum(<span class="st">"bij,bj-&gt;bi"</span>,</span>
<span id="cb33-37"><a href="#cb33-37" aria-hidden="true" tabindex="-1"></a>                    reciprocal_lattice_metric_tensor, PO_axis))</span>
<span id="cb33-38"><a href="#cb33-38" aria-hidden="true" tabindex="-1"></a>    one_minus_cosP_sqd <span class="op">=</span> <span class="fl">1.0</span><span class="op">-</span>cosP<span class="op">**</span><span class="dv">2</span></span>
<span id="cb33-39"><a href="#cb33-39" aria-hidden="true" tabindex="-1"></a>    one_minus_cosP_sqd[one_minus_cosP_sqd <span class="op">&lt;</span> <span class="fl">0.</span>] <span class="op">*=</span> <span class="fl">0.</span></span>
<span id="cb33-40"><a href="#cb33-40" aria-hidden="true" tabindex="-1"></a>    sinP <span class="op">=</span> torch.sqrt(one_minus_cosP_sqd)</span>
<span id="cb33-41"><a href="#cb33-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-42"><a href="#cb33-42" aria-hidden="true" tabindex="-1"></a>    <span class="co"># MD factor = 1 means no PO. Use a normal distribution with std given in the</span></span>
<span id="cb33-43"><a href="#cb33-43" aria-hidden="true" tabindex="-1"></a>    <span class="co"># argument centred at 1.</span></span>
<span id="cb33-44"><a href="#cb33-44" aria-hidden="true" tabindex="-1"></a>    factor <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> (torch.randn((batchsize,<span class="dv">1</span>),device<span class="op">=</span>device,dtype<span class="op">=</span>dtype) <span class="op">*</span> factor_std)</span>
<span id="cb33-45"><a href="#cb33-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-46"><a href="#cb33-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cosP, sinP, factor, PO_axis</span>
<span id="cb33-47"><a href="#cb33-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-48"><a href="#cb33-48" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> apply_MD_PO_correction(intensities, cosP, sinP, factor):</span>
<span id="cb33-49"><a href="#cb33-49" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Modifies the intensities to account for preferred orientation effects</span></span>
<span id="cb33-50"><a href="#cb33-50" aria-hidden="true" tabindex="-1"></a><span class="co">    using the method of March and Dollase.</span></span>
<span id="cb33-51"><a href="#cb33-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-52"><a href="#cb33-52" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb33-53"><a href="#cb33-53" aria-hidden="true" tabindex="-1"></a><span class="co">        intensities (tensor):   Original intensities for the reflections.</span></span>
<span id="cb33-54"><a href="#cb33-54" aria-hidden="true" tabindex="-1"></a><span class="co">            Shape = (batch, number of reflections)</span></span>
<span id="cb33-55"><a href="#cb33-55" aria-hidden="true" tabindex="-1"></a><span class="co">        cosP (tensor):  Cosine of the angle between the Miller indices and the</span></span>
<span id="cb33-56"><a href="#cb33-56" aria-hidden="true" tabindex="-1"></a><span class="co">            preferred orientation axis. Calculated in get_MD_PO_components</span></span>
<span id="cb33-57"><a href="#cb33-57" aria-hidden="true" tabindex="-1"></a><span class="co">            Shape = (batch, number of reflections)</span></span>
<span id="cb33-58"><a href="#cb33-58" aria-hidden="true" tabindex="-1"></a><span class="co">        sinP (tensor):  Sine of the angle between the Miller indices and the</span></span>
<span id="cb33-59"><a href="#cb33-59" aria-hidden="true" tabindex="-1"></a><span class="co">            preferred orientation axis. Calculated in get_MD_PO_components</span></span>
<span id="cb33-60"><a href="#cb33-60" aria-hidden="true" tabindex="-1"></a><span class="co">            Shape = (batch, number of reflections)</span></span>
<span id="cb33-61"><a href="#cb33-61" aria-hidden="true" tabindex="-1"></a><span class="co">        factor (tensor): The March-Dollase factors. Shape = (batch,1)</span></span>
<span id="cb33-62"><a href="#cb33-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-63"><a href="#cb33-63" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb33-64"><a href="#cb33-64" aria-hidden="true" tabindex="-1"></a><span class="co">        tensor: Modified intensities for the reflections given preferred</span></span>
<span id="cb33-65"><a href="#cb33-65" aria-hidden="true" tabindex="-1"></a><span class="co">        orientation. Shape = (batch, number of reflections)</span></span>
<span id="cb33-66"><a href="#cb33-66" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb33-67"><a href="#cb33-67" aria-hidden="true" tabindex="-1"></a>    A_all <span class="op">=</span> (<span class="fl">1.0</span><span class="op">/</span>torch.sqrt(((factor)<span class="op">*</span>cosP)<span class="op">**</span><span class="dv">2</span><span class="op">+</span>sinP<span class="op">**</span><span class="dv">2</span><span class="op">/</span>(factor)))<span class="op">**</span><span class="dv">3</span></span>
<span id="cb33-68"><a href="#cb33-68" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> intensities <span class="op">*</span> A_all</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="peak-shapes" class="level2">
<h2 class="anchored" data-anchor-id="peak-shapes">Peak shapes</h2>
<p>Now that we can calculate where the peaks will be, and modulate the intensity of the peaks if we want to, we now need to think about the shape of the peaks.</p>
<p>There are several possible peak shapes that we could go for, however, in order to try to get relatively realistic results, I decided to implement full Voigt functions, and also include the <a href="https://scripts.iucr.org/cgi-bin/paper?hn0025">Finger, Cox and Jephcoat</a> correction for peak asymmetry due to axial divergence. I also decided to implement peak broadening as a function of the peak position, using the well established U,V,W,X,Y,Z parameters described <a href="https://journals.iucr.org/j/issues/2021/06/00/gj5272/">here</a> and elsewhere.</p>
<p>We therefore need to calculate gaussian, lorentzian and the FCJ profile for each peak in the data, then convolve them together. Using the <a href="https://en.wikipedia.org/wiki/Convolution_theorem">convolution theorem</a>, we can do this by first Fourier transforming them, calculating their pointwise product in Fourier space, then inverse Fourier transforming the resultant product.</p>
<div class="cell" data-execution_count="22">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> gaussian(x, mu, sig):</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Calculate a gaussian peak</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="co">        x (tensor): the x-coordinates for the peak. Shape = (datapoints)</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="co">        mu (tensor): the mean of the gaussian.</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a><span class="co">            Shape = (batch, number of peaks, 1)</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a><span class="co">        sig (tensor): the standard deviation of the gaussian.</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a><span class="co">            Shape = (batch, number of peaks, 1)</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a><span class="co">        tensor: the gaussian peaks centered at mu with standard deviation sig.</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a><span class="co">            Intensities scaled to max = 1.</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a><span class="co">            Shape = (batch, number of peaks, datapoints)</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>    root_two_pi <span class="op">=</span> <span class="fl">2.5066282746310002</span></span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>    peak <span class="op">=</span> (<span class="dv">1</span><span class="op">/</span>(sig<span class="op">*</span>root_two_pi))<span class="op">*</span>torch.exp(<span class="op">-</span><span class="fl">0.5</span><span class="op">*</span>(x<span class="op">-</span>mu)<span class="op">**</span><span class="dv">2</span><span class="op">/</span>sig<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> peak<span class="op">/</span>peak.<span class="bu">max</span>(dim<span class="op">=-</span><span class="dv">1</span>).values.unsqueeze(<span class="dv">2</span>)</span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lorentzian(x, loc, gam):</span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Calcualte a lorentzian peak</span></span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true" tabindex="-1"></a><span class="co">        x (tensor): the x-coordinates for the peak. Shape = (datapoints)</span></span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true" tabindex="-1"></a><span class="co">        loc (tensor): The centre of the peaks.</span></span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true" tabindex="-1"></a><span class="co">            Shape = (batch, number of peaks, 1)</span></span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true" tabindex="-1"></a><span class="co">        gam (tensor): The half width at half max for the peaks.</span></span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true" tabindex="-1"></a><span class="co">             Shape = (batch, number of peaks, 1)</span></span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-31"><a href="#cb34-31" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb34-32"><a href="#cb34-32" aria-hidden="true" tabindex="-1"></a><span class="co">        tensor: the gaussian peaks centered at loc with HWHM gam.</span></span>
<span id="cb34-33"><a href="#cb34-33" aria-hidden="true" tabindex="-1"></a><span class="co">            Intensities scaled to max = 1.</span></span>
<span id="cb34-34"><a href="#cb34-34" aria-hidden="true" tabindex="-1"></a><span class="co">            Shape = (batch, number of peaks, datapoints)</span></span>
<span id="cb34-35"><a href="#cb34-35" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb34-36"><a href="#cb34-36" aria-hidden="true" tabindex="-1"></a>    one_over_pi <span class="op">=</span> <span class="fl">0.3183098861837907</span></span>
<span id="cb34-37"><a href="#cb34-37" aria-hidden="true" tabindex="-1"></a>    peak <span class="op">=</span> one_over_pi<span class="op">*</span>(gam<span class="op">/</span>((x <span class="op">-</span> loc)<span class="op">**</span><span class="dv">2</span><span class="op">+</span>gam<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb34-38"><a href="#cb34-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> peak<span class="op">/</span>peak.<span class="bu">max</span>(dim<span class="op">=-</span><span class="dv">1</span>).values.unsqueeze(<span class="dv">2</span>)</span>
<span id="cb34-39"><a href="#cb34-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-40"><a href="#cb34-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-41"><a href="#cb34-41" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fcj(data,twotheta,shl):</span>
<span id="cb34-42"><a href="#cb34-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Finger, Cox and Jephcoat profile function.</span></span>
<span id="cb34-43"><a href="#cb34-43" aria-hidden="true" tabindex="-1"></a><span class="co">    Code based on GSAS-II function found here:</span></span>
<span id="cb34-44"><a href="#cb34-44" aria-hidden="true" tabindex="-1"></a><span class="co">    https://gsas-ii.readthedocs.io/en/latest/_modules/GSASIIpwd.html#fcjde_gen</span></span>
<span id="cb34-45"><a href="#cb34-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-46"><a href="#cb34-46" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb34-47"><a href="#cb34-47" aria-hidden="true" tabindex="-1"></a><span class="co">        data (tensor): the data to evaluate the function on.</span></span>
<span id="cb34-48"><a href="#cb34-48" aria-hidden="true" tabindex="-1"></a><span class="co">            Shape = (batch, number of peaks, datapoints)</span></span>
<span id="cb34-49"><a href="#cb34-49" aria-hidden="true" tabindex="-1"></a><span class="co">        twotheta (tensor): The position of the peak.</span></span>
<span id="cb34-50"><a href="#cb34-50" aria-hidden="true" tabindex="-1"></a><span class="co">            Shape = (batch, number of peaks, 1)</span></span>
<span id="cb34-51"><a href="#cb34-51" aria-hidden="true" tabindex="-1"></a><span class="co">        shl (tensor): shl = sum(S/L,H/L) where:</span></span>
<span id="cb34-52"><a href="#cb34-52" aria-hidden="true" tabindex="-1"></a><span class="co">            S: sample height</span></span>
<span id="cb34-53"><a href="#cb34-53" aria-hidden="true" tabindex="-1"></a><span class="co">            H: detector opening</span></span>
<span id="cb34-54"><a href="#cb34-54" aria-hidden="true" tabindex="-1"></a><span class="co">            L: sample to detector opening distance</span></span>
<span id="cb34-55"><a href="#cb34-55" aria-hidden="true" tabindex="-1"></a><span class="co">            Shape = (batch, 1)</span></span>
<span id="cb34-56"><a href="#cb34-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-57"><a href="#cb34-57" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb34-58"><a href="#cb34-58" aria-hidden="true" tabindex="-1"></a><span class="co">        tensor: The Finger, Cox and Jephcoat profiles for the peaks</span></span>
<span id="cb34-59"><a href="#cb34-59" aria-hidden="true" tabindex="-1"></a><span class="co">            Shape = (batch, number of peaks, datapoints)</span></span>
<span id="cb34-60"><a href="#cb34-60" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb34-61"><a href="#cb34-61" aria-hidden="true" tabindex="-1"></a>    pi_over_180 <span class="op">=</span> <span class="fl">0.017453292519943295</span></span>
<span id="cb34-62"><a href="#cb34-62" aria-hidden="true" tabindex="-1"></a>    step <span class="op">=</span> data[<span class="dv">1</span>] <span class="op">-</span> data[<span class="dv">0</span>]</span>
<span id="cb34-63"><a href="#cb34-63" aria-hidden="true" tabindex="-1"></a>    T <span class="op">=</span> step<span class="op">*</span>data<span class="op">+</span>twotheta</span>
<span id="cb34-64"><a href="#cb34-64" aria-hidden="true" tabindex="-1"></a>    abs_cos_T <span class="op">=</span> torch.<span class="bu">abs</span>(torch.cos(T<span class="op">*</span>pi_over_180))</span>
<span id="cb34-65"><a href="#cb34-65" aria-hidden="true" tabindex="-1"></a>    abs_cos_T_sqd <span class="op">=</span> abs_cos_T<span class="op">**</span><span class="dv">2</span></span>
<span id="cb34-66"><a href="#cb34-66" aria-hidden="true" tabindex="-1"></a>    cos_sqd_twotheta <span class="op">=</span> torch.cos(twotheta<span class="op">*</span>pi_over_180)<span class="op">**</span><span class="dv">2</span></span>
<span id="cb34-67"><a href="#cb34-67" aria-hidden="true" tabindex="-1"></a>    cos_sqd_twotheta <span class="op">=</span> torch.where(abs_cos_T_sqd<span class="op">&gt;</span>cos_sqd_twotheta,</span>
<span id="cb34-68"><a href="#cb34-68" aria-hidden="true" tabindex="-1"></a>                                    cos_sqd_twotheta,abs_cos_T_sqd)</span>
<span id="cb34-69"><a href="#cb34-69" aria-hidden="true" tabindex="-1"></a>    fcj_profile <span class="op">=</span> torch.where(abs_cos_T_sqd<span class="op">&gt;</span>cos_sqd_twotheta,</span>
<span id="cb34-70"><a href="#cb34-70" aria-hidden="true" tabindex="-1"></a>                    (torch.sqrt(cos_sqd_twotheta<span class="op">/</span>(abs_cos_T_sqd<span class="op">-</span>cos_sqd_twotheta<span class="op">+</span><span class="fl">1e-9</span>))</span>
<span id="cb34-71"><a href="#cb34-71" aria-hidden="true" tabindex="-1"></a>                    <span class="op">-</span><span class="fl">1.</span><span class="op">/</span>shl)<span class="op">/</span>abs_cos_T,<span class="fl">0.0</span>)</span>
<span id="cb34-72"><a href="#cb34-72" aria-hidden="true" tabindex="-1"></a>    fcj_profile <span class="op">=</span> torch.where(fcj_profile <span class="op">&gt;</span> <span class="fl">0.</span>,fcj_profile,<span class="fl">0.</span>)</span>
<span id="cb34-73"><a href="#cb34-73" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sometimes the FCJ profile returned is all zeros. We don't want to separate</span></span>
<span id="cb34-74"><a href="#cb34-74" aria-hidden="true" tabindex="-1"></a>    <span class="co"># these out with loops etc, so need to deal with them. We'll replace zero entry</span></span>
<span id="cb34-75"><a href="#cb34-75" aria-hidden="true" tabindex="-1"></a>    <span class="co"># with an array like this ([1, 0, 0, ..., 0]) which gives ([1, 1, 1, ..., 1])</span></span>
<span id="cb34-76"><a href="#cb34-76" aria-hidden="true" tabindex="-1"></a>    <span class="co"># after the Fourier transform. Then then means that the pointwise multiplication</span></span>
<span id="cb34-77"><a href="#cb34-77" aria-hidden="true" tabindex="-1"></a>    <span class="co"># of the FT Gaussian and Lorentzian components can still occur unaffected</span></span>
<span id="cb34-78"><a href="#cb34-78" aria-hidden="true" tabindex="-1"></a>    zero_sum <span class="op">=</span> (fcj_profile.<span class="bu">sum</span>(dim<span class="op">=-</span><span class="dv">1</span>) <span class="op">==</span> <span class="dv">0</span>).<span class="bu">type</span>(fcj_profile.dtype)</span>
<span id="cb34-79"><a href="#cb34-79" aria-hidden="true" tabindex="-1"></a>    fcj_profile[:,:,<span class="dv">0</span>] <span class="op">+=</span> zero_sum</span>
<span id="cb34-80"><a href="#cb34-80" aria-hidden="true" tabindex="-1"></a>    <span class="co">#first_zero = torch.zeros_like(x)</span></span>
<span id="cb34-81"><a href="#cb34-81" aria-hidden="true" tabindex="-1"></a>    <span class="co">#first_zero[0] = 1</span></span>
<span id="cb34-82"><a href="#cb34-82" aria-hidden="true" tabindex="-1"></a>    <span class="co">#batch_first_zero = (zero_sum * first_zero.unsqueeze(0))</span></span>
<span id="cb34-83"><a href="#cb34-83" aria-hidden="true" tabindex="-1"></a>    <span class="co">#peak_FCJ += batch_first_zero</span></span>
<span id="cb34-84"><a href="#cb34-84" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fcj_profile</span>
<span id="cb34-85"><a href="#cb34-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-86"><a href="#cb34-86" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_UVWZ(batchsize, device, dtype, U_min<span class="op">=</span><span class="fl">0.0001</span>, U_max<span class="op">=</span><span class="fl">0.0004</span>,</span>
<span id="cb34-87"><a href="#cb34-87" aria-hidden="true" tabindex="-1"></a>            V_min<span class="op">=</span><span class="fl">0.0001</span>, V_max<span class="op">=</span><span class="fl">0.0004</span>, W_min<span class="op">=</span><span class="fl">0.0001</span>, W_max<span class="op">=</span><span class="fl">0.0004</span>,</span>
<span id="cb34-88"><a href="#cb34-88" aria-hidden="true" tabindex="-1"></a>            Z_min<span class="op">=</span><span class="fl">0.0001</span>, Z_max<span class="op">=</span><span class="fl">0.0004</span>):</span>
<span id="cb34-89"><a href="#cb34-89" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb34-90"><a href="#cb34-90" aria-hidden="true" tabindex="-1"></a><span class="co">    Get parameters for Gaussian HWHM. Defaults should give reasonable data to</span></span>
<span id="cb34-91"><a href="#cb34-91" aria-hidden="true" tabindex="-1"></a><span class="co">    resemble laboratory diffraction data</span></span>
<span id="cb34-92"><a href="#cb34-92" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb34-93"><a href="#cb34-93" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> ((torch.rand(batchsize, device<span class="op">=</span>device, dtype<span class="op">=</span>dtype) <span class="op">*</span> (U_max<span class="op">-</span>U_min))</span>
<span id="cb34-94"><a href="#cb34-94" aria-hidden="true" tabindex="-1"></a>            <span class="op">+</span> U_min).unsqueeze(<span class="dv">1</span>)</span>
<span id="cb34-95"><a href="#cb34-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-96"><a href="#cb34-96" aria-hidden="true" tabindex="-1"></a>    V <span class="op">=</span> ((torch.rand(batchsize, device<span class="op">=</span>device, dtype<span class="op">=</span>dtype) <span class="op">*</span> (V_max<span class="op">-</span>V_min))</span>
<span id="cb34-97"><a href="#cb34-97" aria-hidden="true" tabindex="-1"></a>            <span class="op">+</span> V_min).unsqueeze(<span class="dv">1</span>)</span>
<span id="cb34-98"><a href="#cb34-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-99"><a href="#cb34-99" aria-hidden="true" tabindex="-1"></a>    W <span class="op">=</span> ((torch.rand(batchsize, device<span class="op">=</span>device, dtype<span class="op">=</span>dtype) <span class="op">*</span> (W_max<span class="op">-</span>W_min))</span>
<span id="cb34-100"><a href="#cb34-100" aria-hidden="true" tabindex="-1"></a>            <span class="op">+</span> W_min).unsqueeze(<span class="dv">1</span>)</span>
<span id="cb34-101"><a href="#cb34-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-102"><a href="#cb34-102" aria-hidden="true" tabindex="-1"></a>    Z <span class="op">=</span> ((torch.rand(batchsize, device<span class="op">=</span>device, dtype<span class="op">=</span>dtype) <span class="op">*</span> (Z_max<span class="op">-</span>Z_min))</span>
<span id="cb34-103"><a href="#cb34-103" aria-hidden="true" tabindex="-1"></a>            <span class="op">+</span> Z_min).unsqueeze(<span class="dv">1</span>)</span>
<span id="cb34-104"><a href="#cb34-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-105"><a href="#cb34-105" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> U, V, W, Z</span>
<span id="cb34-106"><a href="#cb34-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-107"><a href="#cb34-107" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_XY(batchsize, device, dtype, X_min<span class="op">=</span><span class="fl">0.001</span>, X_max<span class="op">=</span><span class="fl">0.035</span>,</span>
<span id="cb34-108"><a href="#cb34-108" aria-hidden="true" tabindex="-1"></a>            Y_min<span class="op">=</span><span class="fl">0.001</span>,Y_max<span class="op">=</span><span class="fl">0.035</span>):</span>
<span id="cb34-109"><a href="#cb34-109" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb34-110"><a href="#cb34-110" aria-hidden="true" tabindex="-1"></a><span class="co">    Get parameters for Lorentzian HWHM. Defaults should give reasonable data to</span></span>
<span id="cb34-111"><a href="#cb34-111" aria-hidden="true" tabindex="-1"></a><span class="co">    resemble laboratory diffraction data</span></span>
<span id="cb34-112"><a href="#cb34-112" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb34-113"><a href="#cb34-113" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> ((torch.rand(batchsize, device<span class="op">=</span>device, dtype<span class="op">=</span>dtype) <span class="op">*</span> (X_max<span class="op">-</span>X_min))</span>
<span id="cb34-114"><a href="#cb34-114" aria-hidden="true" tabindex="-1"></a>            <span class="op">+</span> X_min).unsqueeze(<span class="dv">1</span>)</span>
<span id="cb34-115"><a href="#cb34-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-116"><a href="#cb34-116" aria-hidden="true" tabindex="-1"></a>    Y <span class="op">=</span> ((torch.rand(batchsize, device<span class="op">=</span>device, dtype<span class="op">=</span>dtype) <span class="op">*</span> (Y_max<span class="op">-</span>Y_min))</span>
<span id="cb34-117"><a href="#cb34-117" aria-hidden="true" tabindex="-1"></a>            <span class="op">+</span> Y_min).unsqueeze(<span class="dv">1</span>)</span>
<span id="cb34-118"><a href="#cb34-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-119"><a href="#cb34-119" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> X, Y</span>
<span id="cb34-120"><a href="#cb34-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-121"><a href="#cb34-121" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_hwhm_G(tan_twotheta, cos_twotheta, U, V, W, Z):</span>
<span id="cb34-122"><a href="#cb34-122" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Calculate Gaussian HWHM as a function of peak position and U,V,W and Z params</span></span>
<span id="cb34-123"><a href="#cb34-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-124"><a href="#cb34-124" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb34-125"><a href="#cb34-125" aria-hidden="true" tabindex="-1"></a><span class="co">        tan_twotheta (tensor): tangent of the twotheta peak positions</span></span>
<span id="cb34-126"><a href="#cb34-126" aria-hidden="true" tabindex="-1"></a><span class="co">        cos_twotheta (tensor): tangent of the twotheta peak positions</span></span>
<span id="cb34-127"><a href="#cb34-127" aria-hidden="true" tabindex="-1"></a><span class="co">        U (tensor): peakshape parameter U</span></span>
<span id="cb34-128"><a href="#cb34-128" aria-hidden="true" tabindex="-1"></a><span class="co">        V (tensor): peakshape parameter V</span></span>
<span id="cb34-129"><a href="#cb34-129" aria-hidden="true" tabindex="-1"></a><span class="co">        W (tensor): peakshape parameter W</span></span>
<span id="cb34-130"><a href="#cb34-130" aria-hidden="true" tabindex="-1"></a><span class="co">        Z (tensor): peakshape parameter Z</span></span>
<span id="cb34-131"><a href="#cb34-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-132"><a href="#cb34-132" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb34-133"><a href="#cb34-133" aria-hidden="true" tabindex="-1"></a><span class="co">        tensor: HWHM for the gaussian peaks</span></span>
<span id="cb34-134"><a href="#cb34-134" aria-hidden="true" tabindex="-1"></a><span class="co">            Shape = (batch, number of peaks)</span></span>
<span id="cb34-135"><a href="#cb34-135" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb34-136"><a href="#cb34-136" aria-hidden="true" tabindex="-1"></a>    tan_twotheta <span class="op">=</span> tan_twotheta.squeeze()</span>
<span id="cb34-137"><a href="#cb34-137" aria-hidden="true" tabindex="-1"></a>    cos_twotheta <span class="op">=</span> cos_twotheta.squeeze()</span>
<span id="cb34-138"><a href="#cb34-138" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> torch.sqrt((U <span class="op">*</span> tan_twotheta<span class="op">**</span><span class="dv">2</span>) <span class="op">+</span> (V <span class="op">*</span> tan_twotheta)</span>
<span id="cb34-139"><a href="#cb34-139" aria-hidden="true" tabindex="-1"></a>                        <span class="op">+</span> W <span class="op">+</span> (Z<span class="op">/</span>(cos_twotheta<span class="op">**</span><span class="dv">2</span>))).unsqueeze(<span class="dv">2</span>)</span>
<span id="cb34-140"><a href="#cb34-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-141"><a href="#cb34-141" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_hwhm_L(tan_twotheta, cos_twotheta, X, Y):</span>
<span id="cb34-142"><a href="#cb34-142" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Calculate Lorentzian HWHM as a function of peak position and X and Y params</span></span>
<span id="cb34-143"><a href="#cb34-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-144"><a href="#cb34-144" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb34-145"><a href="#cb34-145" aria-hidden="true" tabindex="-1"></a><span class="co">        tan_twotheta (tensor): tangent of the twotheta peak positions</span></span>
<span id="cb34-146"><a href="#cb34-146" aria-hidden="true" tabindex="-1"></a><span class="co">        cos_twotheta (tensor): tangent of the twotheta peak positions</span></span>
<span id="cb34-147"><a href="#cb34-147" aria-hidden="true" tabindex="-1"></a><span class="co">        X (tensor): peakshape parameter X</span></span>
<span id="cb34-148"><a href="#cb34-148" aria-hidden="true" tabindex="-1"></a><span class="co">        Y (tensor): peakshape parameter Y</span></span>
<span id="cb34-149"><a href="#cb34-149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-150"><a href="#cb34-150" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb34-151"><a href="#cb34-151" aria-hidden="true" tabindex="-1"></a><span class="co">        tensor: HWHM for the lorentzian peaks</span></span>
<span id="cb34-152"><a href="#cb34-152" aria-hidden="true" tabindex="-1"></a><span class="co">            Shape = (batch, number of peaks)</span></span>
<span id="cb34-153"><a href="#cb34-153" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb34-154"><a href="#cb34-154" aria-hidden="true" tabindex="-1"></a>    tan_twotheta <span class="op">=</span> tan_twotheta.squeeze()</span>
<span id="cb34-155"><a href="#cb34-155" aria-hidden="true" tabindex="-1"></a>    cos_twotheta <span class="op">=</span> cos_twotheta.squeeze()</span>
<span id="cb34-156"><a href="#cb34-156" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ((X <span class="op">*</span> tan_twotheta) <span class="op">+</span> (Y<span class="op">/</span>cos_twotheta)).unsqueeze(<span class="dv">2</span>)</span>
<span id="cb34-157"><a href="#cb34-157" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-158"><a href="#cb34-158" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_shl(batchsize, device, dtype, shlmax<span class="op">=</span><span class="fl">0.5</span>, rescale<span class="op">=</span><span class="va">True</span>):</span>
<span id="cb34-159"><a href="#cb34-159" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Generate asymmetry parameter for the FCJ profile.</span></span>
<span id="cb34-160"><a href="#cb34-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-161"><a href="#cb34-161" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb34-162"><a href="#cb34-162" aria-hidden="true" tabindex="-1"></a><span class="co">        shl = sum(S/L,H/L) where:</span></span>
<span id="cb34-163"><a href="#cb34-163" aria-hidden="true" tabindex="-1"></a><span class="co">            S: sample height</span></span>
<span id="cb34-164"><a href="#cb34-164" aria-hidden="true" tabindex="-1"></a><span class="co">            H: detector opening</span></span>
<span id="cb34-165"><a href="#cb34-165" aria-hidden="true" tabindex="-1"></a><span class="co">            L: sample to detector opening distance</span></span>
<span id="cb34-166"><a href="#cb34-166" aria-hidden="true" tabindex="-1"></a><span class="co">        This is scaled by 1/57.2958 if rescale is True, in keeping with the scaling</span></span>
<span id="cb34-167"><a href="#cb34-167" aria-hidden="true" tabindex="-1"></a><span class="co">        applied in the original GSAS-II code</span></span>
<span id="cb34-168"><a href="#cb34-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-169"><a href="#cb34-169" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb34-170"><a href="#cb34-170" aria-hidden="true" tabindex="-1"></a><span class="co">        tensor: The asymmetry parameter for the FCJ profiles</span></span>
<span id="cb34-171"><a href="#cb34-171" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb34-172"><a href="#cb34-172" aria-hidden="true" tabindex="-1"></a>    shl <span class="op">=</span> torch.rand((batchsize, <span class="dv">1</span>, <span class="dv">1</span>), device<span class="op">=</span>device, dtype<span class="op">=</span>dtype) <span class="op">*</span> shlmax</span>
<span id="cb34-173"><a href="#cb34-173" aria-hidden="true" tabindex="-1"></a>    shl <span class="op">/=</span> <span class="fl">57.2958</span></span>
<span id="cb34-174"><a href="#cb34-174" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> shl</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="background-and-noise" class="level2">
<h2 class="anchored" data-anchor-id="background-and-noise">Background and noise</h2>
<p>The experimental noise can be modelled as gaussian noise, which we can add very easily to the calculated diffraction data. For the background shape, we can use <a href="https://en.wikipedia.org/wiki/Chebyshev_polynomials">Chebyshev polynomials</a>.</p>
<div class="cell" data-execution_count="23">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_noise(calculated_patterns, noise_min <span class="op">=</span> <span class="fl">0.0001</span>, noise_max <span class="op">=</span> <span class="fl">0.0025</span>):</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Get noise for the diffraction patterns to simulate experimental data</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="co">        calculated_patterns (tensor): The diffraction patterns.</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="co">            Shape = (batch, points in profile)</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a><span class="co">        noise_min (float, optional): Minimum standard deviation for the</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a><span class="co">            Gaussian noise. Defaults to 0.0001.</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a><span class="co">        noise_max (float, optional): Maximum standard deviation for the</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a><span class="co">            Gaussian noise. Defaults to 0.0025.</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a><span class="co">        tensor: Noise to be added to the diffraction patterns</span></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>    batchsize <span class="op">=</span> calculated_patterns.shape[<span class="dv">0</span>]</span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>    device <span class="op">=</span> calculated_patterns.device</span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>    dtype <span class="op">=</span> calculated_patterns.dtype</span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a>    noise_std <span class="op">=</span> torch.rand((batchsize,<span class="dv">1</span>), device<span class="op">=</span>device, dtype<span class="op">=</span>dtype) <span class="op">*</span> (noise_max <span class="op">-</span> noise_min) <span class="op">+</span> noise_min</span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>    noise <span class="op">=</span> torch.randn(calculated_patterns.shape, device<span class="op">=</span>device, dtype<span class="op">=</span>dtype) <span class="op">*</span> noise_std</span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> noise</span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_background(batchsize, data, bg_prm_max<span class="op">=</span><span class="fl">0.025</span>, bg_prm_min<span class="op">=</span><span class="fl">0.0</span>, degree<span class="op">=</span><span class="dv">8</span>):</span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Calculate background profiles using Chebyshev polynomials</span></span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb35-26"><a href="#cb35-26" aria-hidden="true" tabindex="-1"></a><span class="co">        batchsize (int): The batch size</span></span>
<span id="cb35-27"><a href="#cb35-27" aria-hidden="true" tabindex="-1"></a><span class="co">        data (tensor): The twotheta values for the diffraction histograms</span></span>
<span id="cb35-28"><a href="#cb35-28" aria-hidden="true" tabindex="-1"></a><span class="co">        bg_prm_max (float, optional): Maximum value for the standard deviation</span></span>
<span id="cb35-29"><a href="#cb35-29" aria-hidden="true" tabindex="-1"></a><span class="co">            of the weights for the Chebyshev polynomial components. Defaults to</span></span>
<span id="cb35-30"><a href="#cb35-30" aria-hidden="true" tabindex="-1"></a><span class="co">            0.025.</span></span>
<span id="cb35-31"><a href="#cb35-31" aria-hidden="true" tabindex="-1"></a><span class="co">        bg_prm_min (float, optional): Minimum value for the standard deviation</span></span>
<span id="cb35-32"><a href="#cb35-32" aria-hidden="true" tabindex="-1"></a><span class="co">            of the weights for the Chebyshev polynomial components. Defaults to</span></span>
<span id="cb35-33"><a href="#cb35-33" aria-hidden="true" tabindex="-1"></a><span class="co">            0.0.</span></span>
<span id="cb35-34"><a href="#cb35-34" aria-hidden="true" tabindex="-1"></a><span class="co">        degree (int, optional): The degree of Chebyshev polynomial to use for</span></span>
<span id="cb35-35"><a href="#cb35-35" aria-hidden="true" tabindex="-1"></a><span class="co">            the backgrounds. Defaults to 8.</span></span>
<span id="cb35-36"><a href="#cb35-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-37"><a href="#cb35-37" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb35-38"><a href="#cb35-38" aria-hidden="true" tabindex="-1"></a><span class="co">        tensor: Background profiles. Shape = (batch, number of points in histogram)</span></span>
<span id="cb35-39"><a href="#cb35-39" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb35-40"><a href="#cb35-40" aria-hidden="true" tabindex="-1"></a>    device <span class="op">=</span> data.device</span>
<span id="cb35-41"><a href="#cb35-41" aria-hidden="true" tabindex="-1"></a>    dtype <span class="op">=</span> data.dtype</span>
<span id="cb35-42"><a href="#cb35-42" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> torch.arange(degree,device<span class="op">=</span>device,dtype<span class="op">=</span>dtype).unsqueeze(<span class="dv">1</span>)</span>
<span id="cb35-43"><a href="#cb35-43" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Scale data into range -1 to +1</span></span>
<span id="cb35-44"><a href="#cb35-44" aria-hidden="true" tabindex="-1"></a>    ttstar <span class="op">=</span> <span class="dv">2</span><span class="op">*</span>(data <span class="op">-</span> data.<span class="bu">min</span>())<span class="op">/</span>(data.<span class="bu">max</span>() <span class="op">-</span> data.<span class="bu">min</span>()) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb35-45"><a href="#cb35-45" aria-hidden="true" tabindex="-1"></a>    chebyshev_basis <span class="op">=</span> torch.cos(n<span class="op">*</span>torch.arccos(ttstar))</span>
<span id="cb35-46"><a href="#cb35-46" aria-hidden="true" tabindex="-1"></a>    params <span class="op">=</span> (((torch.rand((batchsize,<span class="dv">1</span>,<span class="dv">1</span>), device<span class="op">=</span>device, dtype<span class="op">=</span>dtype)</span>
<span id="cb35-47"><a href="#cb35-47" aria-hidden="true" tabindex="-1"></a>                <span class="op">*</span> (bg_prm_max <span class="op">-</span> bg_prm_min)) <span class="op">+</span> bg_prm_min)</span>
<span id="cb35-48"><a href="#cb35-48" aria-hidden="true" tabindex="-1"></a>                <span class="op">*</span> torch.randn((batchsize, chebyshev_basis.shape[<span class="dv">0</span>], <span class="dv">1</span>),</span>
<span id="cb35-49"><a href="#cb35-49" aria-hidden="true" tabindex="-1"></a>                device<span class="op">=</span>device, dtype<span class="op">=</span>dtype))</span>
<span id="cb35-50"><a href="#cb35-50" aria-hidden="true" tabindex="-1"></a>    bg <span class="op">=</span> (params <span class="op">*</span> chebyshev_basis).<span class="bu">sum</span>(dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb35-51"><a href="#cb35-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> bg</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>A quick test to see if these functions work and generate sensible looking noise and backgrounds:</p>
<div class="cell" data-execution_count="25">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> torch.linspace(<span class="dv">4</span>,<span class="dv">44</span>,<span class="dv">2048</span>).<span class="bu">float</span>()</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>batchsize <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>bgs <span class="op">=</span> get_background(batchsize, data, degree<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>bgs <span class="op">-=</span> bgs.<span class="bu">min</span>(dim<span class="op">=-</span><span class="dv">1</span>).values.unsqueeze(<span class="dv">1</span>)</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>noise <span class="op">=</span> get_noise(bgs)</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>,<span class="dv">1</span>,figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">6</span>))</span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> bg <span class="kw">in</span> (bgs<span class="op">+</span>noise):</span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>    ax.plot(data, bg)</span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">"$2</span><span class="ch">\\</span><span class="st">theta$"</span>)</span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">"Randomly generated backgrounds with noise"</span>)</span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="2023-09-08-Generating-synthetic-PXRD-data_files/figure-html/cell-30-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Some funky background shapes are possible with randomly generated Chebyshev polynomials! We can also see varying levels of noise being added to the profiles.</p>
<p>We now need functions to tie everything together and start to generate some data</p>
<div class="cell" data-execution_count="26">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_peak_positions(crystal_systems, hkl, intensities, unit_cells,</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>                    perturbation_stddev<span class="op">=</span><span class="fl">0.05</span>, zpemin<span class="op">=</span><span class="fl">0.03</span>, zpemax<span class="op">=</span><span class="fl">0.03</span>, wavelength<span class="op">=</span><span class="fl">1.54056</span>):</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    batchsize <span class="op">=</span> intensities.shape[<span class="dv">0</span>]</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>    dtype <span class="op">=</span> intensities.dtype</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>    device <span class="op">=</span> intensities.device</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>    cell_perturbation <span class="op">=</span> get_unit_cell_perturbation(crystal_systems,</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>                                    dtype<span class="op">=</span>dtype, stddev<span class="op">=</span>perturbation_stddev)</span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>    new_unit_cells <span class="op">=</span> unit_cells <span class="op">+</span> cell_perturbation</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>    lattice_matrix, valid <span class="op">=</span> get_lattice_matrix(new_unit_cells)</span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get rid of any invalid unit cells after perturbation</span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> valid.<span class="bu">sum</span>() <span class="op">!=</span> valid.shape[<span class="dv">0</span>]:</span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>        <span class="im">import</span> warnings</span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>        warnings.warn(<span class="st">"Invalid cells generated"</span>)</span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a>        lattice_matrix <span class="op">=</span> lattice_matrix[valid]</span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a>        hkl <span class="op">=</span> hkl[valid]</span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>        intensities <span class="op">=</span> intensities[valid]</span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a>        batchsize <span class="op">=</span> intensities.shape[<span class="dv">0</span>]</span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a>    reciprocal_lattice_matrix <span class="op">=</span> torch.linalg.inv(lattice_matrix)</span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a>    reciprocal_lattice_metric_tensor <span class="op">=</span> get_recip_lattice_metric_tensor(reciprocal_lattice_matrix)</span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a>    d_spacing <span class="op">=</span> get_d_spacing(reciprocal_lattice_metric_tensor, hkl)</span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a>    zpe <span class="op">=</span> get_zero_point_error(batchsize, device, dtype, zpemin<span class="op">=</span>zpemin, zpemax<span class="op">=</span>zpemax)</span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a>    twotheta <span class="op">=</span> zpe <span class="op">+</span> d_to_tt(d_spacing, wavelength)</span>
<span id="cb37-25"><a href="#cb37-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-26"><a href="#cb37-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> twotheta, reciprocal_lattice_metric_tensor, hkl, intensities, d_spacing</span>
<span id="cb37-27"><a href="#cb37-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-28"><a href="#cb37-28" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_PO_intensities(hkl, reciprocal_lattice_metric_tensor, dspacing, intensities, PO_std<span class="op">=</span><span class="fl">0.1</span>):</span>
<span id="cb37-29"><a href="#cb37-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Now apply PO perturbation to the peak intensities</span></span>
<span id="cb37-30"><a href="#cb37-30" aria-hidden="true" tabindex="-1"></a>    cosP, sinP, MDfactor, PO_axis <span class="op">=</span> get_MD_PO_components(hkl,</span>
<span id="cb37-31"><a href="#cb37-31" aria-hidden="true" tabindex="-1"></a>                                    reciprocal_lattice_metric_tensor, dspacing, factor_std<span class="op">=</span>PO_std)</span>
<span id="cb37-32"><a href="#cb37-32" aria-hidden="true" tabindex="-1"></a>    intensities <span class="op">=</span> apply_MD_PO_correction(intensities, cosP, sinP, MDfactor)</span>
<span id="cb37-33"><a href="#cb37-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> torch.nan_to_num(intensities)</span>
<span id="cb37-34"><a href="#cb37-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-35"><a href="#cb37-35" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_peak_shape_params(twotheta, U_min<span class="op">=</span><span class="fl">0.0001</span>, U_max<span class="op">=</span><span class="fl">0.0004</span>,</span>
<span id="cb37-36"><a href="#cb37-36" aria-hidden="true" tabindex="-1"></a>                        V_min<span class="op">=</span><span class="fl">0.0001</span>, V_max<span class="op">=</span><span class="fl">0.0004</span>, W_min<span class="op">=</span><span class="fl">0.0001</span>, W_max<span class="op">=</span><span class="fl">0.0004</span>,</span>
<span id="cb37-37"><a href="#cb37-37" aria-hidden="true" tabindex="-1"></a>                        Z_min<span class="op">=</span><span class="fl">0.0001</span>, Z_max<span class="op">=</span><span class="fl">0.0004</span>, X_min<span class="op">=</span><span class="fl">0.001</span>, X_max<span class="op">=</span><span class="fl">0.035</span>,</span>
<span id="cb37-38"><a href="#cb37-38" aria-hidden="true" tabindex="-1"></a>                        Y_min<span class="op">=</span><span class="fl">0.001</span>, Y_max<span class="op">=</span><span class="fl">0.035</span>, shlmax<span class="op">=</span><span class="fl">0.5</span>):</span>
<span id="cb37-39"><a href="#cb37-39" aria-hidden="true" tabindex="-1"></a>    batchsize <span class="op">=</span> twotheta.shape[<span class="dv">0</span>]</span>
<span id="cb37-40"><a href="#cb37-40" aria-hidden="true" tabindex="-1"></a>    dtype <span class="op">=</span> twotheta.dtype</span>
<span id="cb37-41"><a href="#cb37-41" aria-hidden="true" tabindex="-1"></a>    device <span class="op">=</span> twotheta.device</span>
<span id="cb37-42"><a href="#cb37-42" aria-hidden="true" tabindex="-1"></a>    tan_twotheta <span class="op">=</span> torch.tan(twotheta<span class="op">*</span>torch.pi<span class="op">/</span><span class="fl">180.</span>)</span>
<span id="cb37-43"><a href="#cb37-43" aria-hidden="true" tabindex="-1"></a>    cos_twotheta <span class="op">=</span> torch.cos(twotheta<span class="op">*</span>torch.pi<span class="op">/</span><span class="fl">180.</span>)</span>
<span id="cb37-44"><a href="#cb37-44" aria-hidden="true" tabindex="-1"></a>    U, V, W, Z <span class="op">=</span> get_UVWZ(batchsize, device, dtype, U_min<span class="op">=</span>U_min, U_max<span class="op">=</span>U_max,</span>
<span id="cb37-45"><a href="#cb37-45" aria-hidden="true" tabindex="-1"></a>                        V_min<span class="op">=</span>V_min, V_max<span class="op">=</span>V_max, W_min<span class="op">=</span>W_min, W_max<span class="op">=</span>W_max,</span>
<span id="cb37-46"><a href="#cb37-46" aria-hidden="true" tabindex="-1"></a>                        Z_min<span class="op">=</span>Z_min, Z_max<span class="op">=</span>Z_max)</span>
<span id="cb37-47"><a href="#cb37-47" aria-hidden="true" tabindex="-1"></a>    X, Y <span class="op">=</span> get_XY(batchsize, device, dtype, X_min<span class="op">=</span>X_min, X_max<span class="op">=</span>X_max,</span>
<span id="cb37-48"><a href="#cb37-48" aria-hidden="true" tabindex="-1"></a>                        Y_min<span class="op">=</span>Y_min,Y_max<span class="op">=</span>Y_max)</span>
<span id="cb37-49"><a href="#cb37-49" aria-hidden="true" tabindex="-1"></a>    hwhm_gaussian <span class="op">=</span> get_hwhm_G(tan_twotheta, cos_twotheta, U, V, W, Z)</span>
<span id="cb37-50"><a href="#cb37-50" aria-hidden="true" tabindex="-1"></a>    hwhm_lorentzian <span class="op">=</span> get_hwhm_L(tan_twotheta, cos_twotheta, X, Y)</span>
<span id="cb37-51"><a href="#cb37-51" aria-hidden="true" tabindex="-1"></a>    shl <span class="op">=</span> get_shl(batchsize, device, dtype, shlmax<span class="op">=</span>shlmax, rescale<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb37-52"><a href="#cb37-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> hwhm_gaussian, hwhm_lorentzian, shl</span>
<span id="cb37-53"><a href="#cb37-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-54"><a href="#cb37-54" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_peaks(x, twotheta, intensities, hwhm_gaussian, hwhm_lorentzian, shl):</span>
<span id="cb37-55"><a href="#cb37-55" aria-hidden="true" tabindex="-1"></a>    peak_G <span class="op">=</span>  gaussian(x, torch.zeros_like(twotheta), hwhm_gaussian)</span>
<span id="cb37-56"><a href="#cb37-56" aria-hidden="true" tabindex="-1"></a>    peak_L <span class="op">=</span> lorentzian(x, torch.zeros_like(twotheta), hwhm_lorentzian)</span>
<span id="cb37-57"><a href="#cb37-57" aria-hidden="true" tabindex="-1"></a>    peak_FCJ <span class="op">=</span> fcj(x,twotheta, shl)</span>
<span id="cb37-58"><a href="#cb37-58" aria-hidden="true" tabindex="-1"></a>    peak_GLF <span class="op">=</span> torch.stack([peak_G,peak_L,peak_FCJ],dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb37-59"><a href="#cb37-59" aria-hidden="true" tabindex="-1"></a>    prod_FT_GLF <span class="op">=</span> torch.fft.fft(peak_GLF).prod(dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb37-60"><a href="#cb37-60" aria-hidden="true" tabindex="-1"></a>    peak_voigt <span class="op">=</span> torch.fft.ifft(prod_FT_GLF).real</span>
<span id="cb37-61"><a href="#cb37-61" aria-hidden="true" tabindex="-1"></a>    zero_sum <span class="op">=</span> peak_FCJ.<span class="bu">sum</span>(dim<span class="op">=-</span><span class="dv">1</span>) <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb37-62"><a href="#cb37-62" aria-hidden="true" tabindex="-1"></a>    peak_voigt[zero_sum.squeeze()] <span class="op">=</span> torch.fft.ifftshift(peak_voigt[zero_sum.squeeze()], dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb37-63"><a href="#cb37-63" aria-hidden="true" tabindex="-1"></a>    peak_voigt <span class="op">/=</span> peak_voigt.<span class="bu">max</span>(dim<span class="op">=</span><span class="dv">2</span>).values.unsqueeze(<span class="dv">2</span>)</span>
<span id="cb37-64"><a href="#cb37-64" aria-hidden="true" tabindex="-1"></a>    peak_voigt <span class="op">*=</span> intensities</span>
<span id="cb37-65"><a href="#cb37-65" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> peak_voigt</span>
<span id="cb37-66"><a href="#cb37-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-67"><a href="#cb37-67" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_full_patterns(x, full_data, twotheta, peak_voigt, ttmin<span class="op">=</span><span class="fl">4.</span>, ttmax<span class="op">=</span><span class="fl">44.</span>):</span>
<span id="cb37-68"><a href="#cb37-68" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Finally calculate the full diffraction pattern</span></span>
<span id="cb37-69"><a href="#cb37-69" aria-hidden="true" tabindex="-1"></a>    twotheta[twotheta <span class="op">==</span> <span class="dv">0</span>] <span class="op">=</span> torch.inf</span>
<span id="cb37-70"><a href="#cb37-70" aria-hidden="true" tabindex="-1"></a>    twotheta[twotheta <span class="op">&lt;</span> <span class="dv">4</span>] <span class="op">=</span> torch.inf</span>
<span id="cb37-71"><a href="#cb37-71" aria-hidden="true" tabindex="-1"></a>    twotheta[twotheta <span class="op">&gt;</span> <span class="dv">44</span>] <span class="op">=</span> torch.inf</span>
<span id="cb37-72"><a href="#cb37-72" aria-hidden="true" tabindex="-1"></a>    peakidx <span class="op">=</span> torch.<span class="bu">abs</span>((x[<span class="dv">0</span>] <span class="op">+</span> twotheta) <span class="op">-</span> full_data).<span class="bu">min</span>(dim<span class="op">=-</span><span class="dv">1</span>).indices</span>
<span id="cb37-73"><a href="#cb37-73" aria-hidden="true" tabindex="-1"></a>    full_pattern <span class="op">=</span> torch.zeros(<span class="bu">list</span>(peakidx.shape)<span class="op">+</span>[full_data.shape[<span class="dv">0</span>]], device<span class="op">=</span>device, dtype<span class="op">=</span>dtype)</span>
<span id="cb37-74"><a href="#cb37-74" aria-hidden="true" tabindex="-1"></a>    full_pattern <span class="op">=</span> full_pattern.scatter_(<span class="dv">2</span>,</span>
<span id="cb37-75"><a href="#cb37-75" aria-hidden="true" tabindex="-1"></a>                    peakidx.unsqueeze(<span class="dv">2</span>) <span class="op">+</span> torch.arange(x.shape[<span class="dv">0</span>], device<span class="op">=</span>device), peak_voigt<span class="op">*</span>torch.isfinite(twotheta))</span>
<span id="cb37-76"><a href="#cb37-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-77"><a href="#cb37-77" aria-hidden="true" tabindex="-1"></a>    full_pattern <span class="op">=</span> full_pattern.<span class="bu">sum</span>(dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb37-78"><a href="#cb37-78" aria-hidden="true" tabindex="-1"></a>    full_pattern <span class="op">/=</span> full_pattern.<span class="bu">max</span>(dim<span class="op">=</span><span class="dv">1</span>).values.unsqueeze(<span class="dv">1</span>)</span>
<span id="cb37-79"><a href="#cb37-79" aria-hidden="true" tabindex="-1"></a>    full_pattern <span class="op">=</span> full_pattern[:,(full_data <span class="op">&gt;=</span> ttmin) <span class="op">&amp;</span> (full_data <span class="op">&lt;=</span> ttmax)]</span>
<span id="cb37-80"><a href="#cb37-80" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> full_pattern</span>
<span id="cb37-81"><a href="#cb37-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-82"><a href="#cb37-82" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_diffraction_patterns(x, full_data, crystal_systems, hkl, intensities, unit_cells, wavelength<span class="op">=</span><span class="fl">1.54056</span>):</span>
<span id="cb37-83"><a href="#cb37-83" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb37-84"><a href="#cb37-84" aria-hidden="true" tabindex="-1"></a><span class="co">    Expect the input tensors to have their first dimension to be of size batchsize</span></span>
<span id="cb37-85"><a href="#cb37-85" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb37-86"><a href="#cb37-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-87"><a href="#cb37-87" aria-hidden="true" tabindex="-1"></a>    twotheta, reciprocal_lattice_metric_tensor, hkl, intensities, d_spacing <span class="op">=</span> get_peak_positions(crystal_systems, hkl, intensities, unit_cells,</span>
<span id="cb37-88"><a href="#cb37-88" aria-hidden="true" tabindex="-1"></a>                    perturbation_stddev<span class="op">=</span><span class="fl">0.05</span>, zpemin<span class="op">=</span><span class="fl">0.03</span>, zpemax<span class="op">=</span><span class="fl">0.03</span>, wavelength<span class="op">=</span>wavelength)</span>
<span id="cb37-89"><a href="#cb37-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-90"><a href="#cb37-90" aria-hidden="true" tabindex="-1"></a>    twotheta <span class="op">=</span> twotheta.unsqueeze(<span class="dv">2</span>)</span>
<span id="cb37-91"><a href="#cb37-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-92"><a href="#cb37-92" aria-hidden="true" tabindex="-1"></a>    mod_intensities <span class="op">=</span> get_PO_intensities(hkl, reciprocal_lattice_metric_tensor, d_spacing, intensities).unsqueeze(<span class="dv">2</span>)</span>
<span id="cb37-93"><a href="#cb37-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-94"><a href="#cb37-94" aria-hidden="true" tabindex="-1"></a>    hwhm_gaussian, hwhm_lorentzian, shl <span class="op">=</span> get_peak_shape_params(twotheta)</span>
<span id="cb37-95"><a href="#cb37-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-96"><a href="#cb37-96" aria-hidden="true" tabindex="-1"></a>    peak_voigt <span class="op">=</span> calculate_peaks(x, twotheta, mod_intensities, hwhm_gaussian, hwhm_lorentzian, shl)</span>
<span id="cb37-97"><a href="#cb37-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-98"><a href="#cb37-98" aria-hidden="true" tabindex="-1"></a>    calculated_patterns <span class="op">=</span> calculate_full_patterns(x, full_data, twotheta, peak_voigt, ttmin<span class="op">=</span>ttmin, ttmax<span class="op">=</span>ttmax)</span>
<span id="cb37-99"><a href="#cb37-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-100"><a href="#cb37-100" aria-hidden="true" tabindex="-1"></a>    bgs <span class="op">=</span> get_background(calculated_patterns.shape[<span class="dv">0</span>], </span>
<span id="cb37-101"><a href="#cb37-101" aria-hidden="true" tabindex="-1"></a>                        full_data[(full_data <span class="op">&gt;=</span> ttmin) <span class="op">&amp;</span> (full_data <span class="op">&lt;=</span> ttmax)],</span>
<span id="cb37-102"><a href="#cb37-102" aria-hidden="true" tabindex="-1"></a>                        degree<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb37-103"><a href="#cb37-103" aria-hidden="true" tabindex="-1"></a>    noise <span class="op">=</span> get_noise(calculated_patterns)</span>
<span id="cb37-104"><a href="#cb37-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-105"><a href="#cb37-105" aria-hidden="true" tabindex="-1"></a>    calculated_patterns <span class="op">+=</span> bgs <span class="op">+</span> noise</span>
<span id="cb37-106"><a href="#cb37-106" aria-hidden="true" tabindex="-1"></a>    calculated_patterns <span class="op">-=</span> calculated_patterns.<span class="bu">min</span>(dim<span class="op">=</span><span class="dv">1</span>).values.unsqueeze(<span class="dv">1</span>)</span>
<span id="cb37-107"><a href="#cb37-107" aria-hidden="true" tabindex="-1"></a>    calculated_patterns <span class="op">/=</span> calculated_patterns.<span class="bu">max</span>(dim<span class="op">=</span><span class="dv">1</span>).values.unsqueeze(<span class="dv">1</span>)</span>
<span id="cb37-108"><a href="#cb37-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-109"><a href="#cb37-109" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> calculated_patterns</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Let’s test the functions we’ve written using some real diffraction data as a comparison point. We’ll first plot the actual diffraction pattern, then plot several simulated datasets calculated from the unit cell, hkls and intensities extracted by DASH. This will show the effect of the data augmentation we’ve added into the code which modulates the positions, intensities and shapes of the peaks.</p>
<p>The dataset we’ll look at is that for verapamil hydrochloride. We’ll need a function to calculate the Lorentz-polarisation factor for the intensities, as this would have been corrected for in the intensities in the DASH hcv.</p>
<div class="cell" data-execution_count="27">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>v_xye <span class="op">=</span> []</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="st">"./files/Verap.xye"</span>, <span class="st">"r"</span>) <span class="im">as</span> f:</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> f:</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>        line <span class="op">=</span> <span class="bu">list</span>(<span class="bu">filter</span>(<span class="va">None</span>, line.strip().split(<span class="st">" "</span>)))</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>        v_xye.append([<span class="bu">float</span>(x) <span class="cf">for</span> x <span class="kw">in</span> line])</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>v_xye <span class="op">=</span> np.array(v_xye)</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>v_tt, v_i_obs <span class="op">=</span> v_xye[:,<span class="dv">0</span>], v_xye[:,<span class="dv">1</span>]</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>v_i_obs <span class="op">/=</span> v_i_obs.<span class="bu">max</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="28">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lp_factor(twotheta, ttmono<span class="op">=</span>torch.tensor([<span class="dv">28</span>])):</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> torch.cos(ttmono<span class="op">*</span>torch.pi<span class="op">/</span><span class="dv">180</span>)<span class="op">**</span><span class="dv">2</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>    cossqdtt <span class="op">=</span> torch.cos(twotheta<span class="op">*</span>torch.pi<span class="op">/</span><span class="dv">180</span>)<span class="op">**</span><span class="dv">2</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    sintt <span class="op">=</span> torch.sin(twotheta<span class="op">*</span>torch.pi<span class="op">/</span><span class="dv">180</span>)</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (<span class="dv">1</span><span class="op">+</span>A<span class="op">*</span>cossqdtt) <span class="op">/</span> ((<span class="dv">1</span><span class="op">+</span>A)<span class="op">*</span>sintt)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="32">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>device <span class="op">=</span> torch.device(<span class="st">"cpu"</span>)</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>dtype <span class="op">=</span> torch.float32</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>ttmin <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>ttmax <span class="op">=</span> <span class="dv">44</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>peakrange <span class="op">=</span> <span class="fl">3.</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>datadim <span class="op">=</span> <span class="dv">2048</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>full_data <span class="op">=</span> torch.linspace(ttmin<span class="op">-</span>(peakrange<span class="op">/</span><span class="dv">2</span>), ttmax<span class="op">+</span>(peakrange<span class="op">/</span><span class="dv">2</span>), <span class="bu">int</span>(np.ceil((ttmax<span class="op">-</span>ttmin<span class="op">+</span>peakrange)<span class="op">/</span>((ttmax<span class="op">-</span>ttmin)<span class="op">/</span>datadim))), device<span class="op">=</span>device, dtype<span class="op">=</span>dtype)</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>plotdata <span class="op">=</span> full_data[(full_data <span class="op">&gt;=</span> ttmin) <span class="op">&amp;</span> (full_data <span class="op">&lt;=</span> ttmax)].cpu()</span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> (full_data[full_data <span class="op">&lt;=</span> ttmin<span class="op">+</span>(peakrange<span class="op">/</span><span class="dv">2</span>)]).clone() <span class="op">-</span> <span class="dv">4</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>v_hkl <span class="op">=</span> []</span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a>v_i <span class="op">=</span> []</span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="st">"./files/Verap.hcv"</span>, <span class="st">"r"</span>) <span class="im">as</span> f:</span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> f:</span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a>        line <span class="op">=</span> <span class="bu">list</span>(<span class="bu">filter</span>(<span class="va">None</span>, line.strip().split(<span class="st">" "</span>)))</span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a>        v_hkl.append([<span class="bu">int</span>(x) <span class="cf">for</span> x <span class="kw">in</span> line[<span class="dv">0</span>:<span class="dv">3</span>]])</span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a>        v_i.append(<span class="bu">float</span>(line[<span class="dv">3</span>]))</span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true" tabindex="-1"></a>v_hkl <span class="op">=</span> torch.tensor(v_hkl).<span class="bu">float</span>()</span>
<span id="cb40-20"><a href="#cb40-20" aria-hidden="true" tabindex="-1"></a>v_i <span class="op">=</span> torch.tensor(v_i).<span class="bu">float</span>()</span>
<span id="cb40-21"><a href="#cb40-21" aria-hidden="true" tabindex="-1"></a>v_cell <span class="op">=</span> torch.tensor([<span class="fl">7.08991</span>, <span class="fl">10.59464</span>, <span class="fl">19.20684</span>, <span class="fl">100.1068</span>, <span class="fl">93.7396</span>, <span class="fl">101.5610</span>])</span>
<span id="cb40-22"><a href="#cb40-22" aria-hidden="true" tabindex="-1"></a>v_cs <span class="op">=</span> torch.tensor([cs_key[<span class="st">"Monoclinic"</span>]])</span>
<span id="cb40-23"><a href="#cb40-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-24"><a href="#cb40-24" aria-hidden="true" tabindex="-1"></a>repeat <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb40-25"><a href="#cb40-25" aria-hidden="true" tabindex="-1"></a>diffraction_patterns <span class="op">=</span> calculate_diffraction_patterns(x, full_data, v_cs.repeat(repeat), v_hkl.repeat(repeat,<span class="dv">1</span>,<span class="dv">1</span>), v_i.repeat(repeat,<span class="dv">1</span>), v_cell.repeat(repeat,<span class="dv">1</span>))</span>
<span id="cb40-26"><a href="#cb40-26" aria-hidden="true" tabindex="-1"></a>plt.plot(v_tt[v_tt <span class="op">&lt;=</span> <span class="dv">35</span>], v_i_obs[v_tt <span class="op">&lt;=</span> <span class="dv">35</span>])</span>
<span id="cb40-27"><a href="#cb40-27" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Original verapamil hydrochloride diffraction data"</span>)</span>
<span id="cb40-28"><a href="#cb40-28" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"$2</span><span class="ch">\\</span><span class="st">theta$"</span>)</span>
<span id="cb40-29"><a href="#cb40-29" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Intensity"</span>)</span>
<span id="cb40-30"><a href="#cb40-30" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb40-31"><a href="#cb40-31" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>,<span class="dv">2</span>,figsize<span class="op">=</span>(<span class="dv">16</span>,<span class="dv">8</span>))</span>
<span id="cb40-32"><a href="#cb40-32" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, p, <span class="kw">in</span> <span class="bu">enumerate</span>(diffraction_patterns):</span>
<span id="cb40-33"><a href="#cb40-33" aria-hidden="true" tabindex="-1"></a>    col <span class="op">=</span> i <span class="op">%</span> <span class="dv">2</span></span>
<span id="cb40-34"><a href="#cb40-34" aria-hidden="true" tabindex="-1"></a>    row <span class="op">=</span> i <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb40-35"><a href="#cb40-35" aria-hidden="true" tabindex="-1"></a>    corrected_i <span class="op">=</span> (lp_factor(plotdata[plotdata <span class="op">&lt;=</span> <span class="dv">35</span>])<span class="op">*</span>p[plotdata <span class="op">&lt;=</span> <span class="dv">35</span>]).squeeze()</span>
<span id="cb40-36"><a href="#cb40-36" aria-hidden="true" tabindex="-1"></a>    corrected_i <span class="op">-=</span> corrected_i.<span class="bu">min</span>()</span>
<span id="cb40-37"><a href="#cb40-37" aria-hidden="true" tabindex="-1"></a>    corrected_i <span class="op">/=</span> corrected_i.<span class="bu">max</span>()</span>
<span id="cb40-38"><a href="#cb40-38" aria-hidden="true" tabindex="-1"></a>    ax[row][col].plot(plotdata[plotdata <span class="op">&lt;=</span> <span class="dv">35</span>], corrected_i)</span>
<span id="cb40-39"><a href="#cb40-39" aria-hidden="true" tabindex="-1"></a>    ax[row][col].set_xlabel(<span class="st">"$2</span><span class="ch">\\</span><span class="st">theta$"</span>)</span>
<span id="cb40-40"><a href="#cb40-40" aria-hidden="true" tabindex="-1"></a>    ax[row][col].set_ylabel(<span class="st">"Intensity"</span>)</span>
<span id="cb40-41"><a href="#cb40-41" aria-hidden="true" tabindex="-1"></a>fig.suptitle(<span class="st">"Calculated diffraction patterns"</span>)</span>
<span id="cb40-42"><a href="#cb40-42" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="2023-09-08-Generating-synthetic-PXRD-data_files/figure-html/cell-34-output-1.png" class="img-fluid"></p>
</div>
<div class="cell-output cell-output-display">
<p><img src="2023-09-08-Generating-synthetic-PXRD-data_files/figure-html/cell-34-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>The calculated patterns clearly resemble the observed diffraction data, whilst also having subtle differences in the background, noise levels, peak shapes, peak asymmetries as well as the peak positions and intensities.</p>
</section>
</section>
<section id="performance" class="level1">
<h1>Performance</h1>
<p>Let’s test the performance of the generation code on an Nvidia Quadro RTX 5000 GPU (16 GB VRAM). We’ve got about 288k patterns to generate, how long will it take?!</p>
<div class="cell" data-execution_count="33">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>data_dir <span class="op">=</span> <span class="st">"./"</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>base_name <span class="op">=</span> <span class="st">"4-44-CuKa1-data_4000_"</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>crystal_systems <span class="op">=</span> torch.tensor(np.load(data_dir<span class="op">+</span>base_name<span class="op">+</span><span class="st">"crystal_systems_numeric.npy"</span>))</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>hkl             <span class="op">=</span> torch.tensor(np.load(data_dir<span class="op">+</span>base_name<span class="op">+</span><span class="st">"hkl.npy"</span>)).<span class="bu">float</span>()</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>intensities     <span class="op">=</span> torch.tensor(np.load(data_dir<span class="op">+</span>base_name<span class="op">+</span><span class="st">"intensities.npy"</span>)).<span class="bu">float</span>()</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>unit_cell       <span class="op">=</span> torch.tensor(np.load(data_dir<span class="op">+</span>base_name<span class="op">+</span><span class="st">"unit_cell.npy"</span>)).<span class="bu">float</span>()</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>cod_id         <span class="op">=</span> np.load(data_dir<span class="op">+</span>base_name<span class="op">+</span><span class="st">"cod_id.npy"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="35">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tqdm <span class="im">import</span> tqdm</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>device <span class="op">=</span> torch.device(<span class="st">"cuda:0"</span>)</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>dtype <span class="op">=</span> torch.float32</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>ttmin <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>ttmax <span class="op">=</span> <span class="dv">44</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>peakrange <span class="op">=</span> <span class="fl">3.</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>datadim <span class="op">=</span> <span class="dv">2048</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>full_data <span class="op">=</span> torch.linspace(ttmin<span class="op">-</span>(peakrange<span class="op">/</span><span class="dv">2</span>), ttmax<span class="op">+</span>(peakrange<span class="op">/</span><span class="dv">2</span>), <span class="bu">int</span>(np.ceil((ttmax<span class="op">-</span>ttmin<span class="op">+</span>peakrange)<span class="op">/</span>((ttmax<span class="op">-</span>ttmin)<span class="op">/</span>datadim))), device<span class="op">=</span>device, dtype<span class="op">=</span>dtype)</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>plotdata <span class="op">=</span> full_data[(full_data <span class="op">&gt;=</span> ttmin) <span class="op">&amp;</span> (full_data <span class="op">&lt;=</span> ttmax)]</span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> (full_data[full_data <span class="op">&lt;=</span> ttmin<span class="op">+</span>(peakrange<span class="op">/</span><span class="dv">2</span>)]).clone() <span class="op">-</span> ttmin</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>batchsize <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>idx <span class="op">=</span> torch.arange(batchsize)</span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> tqdm(<span class="bu">range</span>(intensities.shape[<span class="dv">0</span>]<span class="op">//</span>batchsize)):</span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>    batch_idx <span class="op">=</span> idx <span class="op">+</span> (i<span class="op">*</span>batchsize)</span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a>    diffraction_patterns <span class="op">=</span> calculate_diffraction_patterns(</span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a>                                        x,</span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a>                                        full_data,</span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a>                                        crystal_systems[batch_idx].to(device),</span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true" tabindex="-1"></a>                                        hkl[batch_idx].to(device),</span>
<span id="cb42-23"><a href="#cb42-23" aria-hidden="true" tabindex="-1"></a>                                        intensities[batch_idx].to(device),</span>
<span id="cb42-24"><a href="#cb42-24" aria-hidden="true" tabindex="-1"></a>                                        unit_cell[batch_idx].to(device)</span>
<span id="cb42-25"><a href="#cb42-25" aria-hidden="true" tabindex="-1"></a>                                    )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>100%|██████████| 288/288 [00:57&lt;00:00,  4.97it/s]</code></pre>
</div>
</div>
<p>288k patterns generated in about a minute - this means we can generate about 5000 diffraction patterns per second!</p>
<p>I’m sure there are some tweaks that would boost the performance even more, but for now this will be good enough for initial experiments with neural networks. A quick check with a profiler could give some hints as to where the biggest bottlenecks in the code are:</p>
<div class="cell" data-execution_count="40">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cProfile <span class="im">as</span> profile</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pstats</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>prof <span class="op">=</span> profile.Profile()</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>prof.enable()</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>diffraction_patterns <span class="op">=</span> calculate_diffraction_patterns(</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>                                        x,</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>                                        full_data,</span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>                                        crystal_systems[batch_idx].to(device),</span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>                                        hkl[batch_idx].to(device),</span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a>                                        intensities[batch_idx].to(device),</span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a>                                        unit_cell[batch_idx].to(device)</span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a>                                    )</span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a>prof.disable()</span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a>stats <span class="op">=</span> pstats.Stats(prof).strip_dirs().sort_stats(<span class="st">"tottime"</span>)</span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a>stats.print_stats(<span class="dv">10</span>) <span class="co"># top 10 rows</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>         294 function calls in 0.422 seconds

   Ordered by: internal time
   List reduced from 94 to 10 due to restriction &lt;10&gt;

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.297    0.297    0.298    0.298 118587661.py:54(calculate_peaks)
        1    0.086    0.086    0.086    0.086 118587661.py:67(calculate_full_patterns)
        4    0.016    0.004    0.016    0.004 {method 'to' of 'torch._C._TensorBase' objects}
        1    0.015    0.015    0.016    0.016 1250221022.py:1(get_MD_PO_components)
        1    0.002    0.002    0.422    0.422 3294103451.py:6(&lt;module&gt;)
        1    0.002    0.002    0.004    0.004 118587661.py:1(get_peak_positions)
        1    0.000    0.000    0.000    0.000 {built-in method torch._C._linalg.linalg_inv}
        1    0.000    0.000    0.001    0.001 895306903.py:3(get_unit_cell_perturbation)
        1    0.000    0.000    0.405    0.405 118587661.py:82(calculate_diffraction_patterns)
        1    0.000    0.000    0.001    0.001 3032108489.py:41(fcj)

</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="40">
<pre><code>&lt;pstats.Stats at 0x1b7da6a57c0&gt;</code></pre>
</div>
</div>
<p>The filenames look a bit odd as I’m running this in a notebook. However, it looks like the peak calculation is taking the most time, which isn’t too surprising to me as there’s a lot going on there! Perhaps in future work I’ll try to improve the efficiency of the code. For now though, I think it’s good enough for us to start experimenting with training neural networks, which will be the subject of future posts.</p>
</section>
<section id="powcod-generated-data" class="level1">
<h1>PowCod generated data</h1>
<p>As a final sense check, let’s see some of the data we can generate from the PowCod database</p>
<div class="cell" data-execution_count="48">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>idx <span class="op">=</span> torch.arange(<span class="dv">4</span>)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>diffraction_patterns <span class="op">=</span> calculate_diffraction_patterns(</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>                                        x,</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>                                        full_data,</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>                                        crystal_systems[idx].to(device),</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>                                        hkl[idx].to(device),</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>                                        intensities[idx].to(device),</span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>                                        unit_cell[idx].to(device)</span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>                                    )</span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>,<span class="dv">2</span>,figsize<span class="op">=</span>(<span class="dv">16</span>,<span class="dv">10</span>))</span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, d <span class="kw">in</span> <span class="bu">enumerate</span>(diffraction_patterns):</span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>    col <span class="op">=</span> i <span class="op">%</span> <span class="dv">2</span></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>    row <span class="op">=</span> i <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>    ax[row][col].plot(plotdata.cpu().numpy(), d.cpu().numpy())</span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a>    ax[row][col].set_xlabel(<span class="st">"$2</span><span class="ch">\\</span><span class="st">theta$"</span>)</span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a>    ax[row][col].set_ylabel(<span class="st">"Intensity"</span>)</span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>    ax[row][col].set_title(<span class="ss">f"</span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss"> - COD entry </span><span class="sc">{</span>cod_id[idx[i]]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss"> - http://www.crystallography.net/cod/</span><span class="sc">{</span>cod_id[idx[i]]<span class="sc">}</span><span class="ss">.html"</span>)</span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>1 - http://www.crystallography.net/cod/7220223.html
2 - http://www.crystallography.net/cod/1553394.html
3 - http://www.crystallography.net/cod/7037807.html
4 - http://www.crystallography.net/cod/7036591.html</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="2023-09-08-Generating-synthetic-PXRD-data_files/figure-html/cell-38-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>I downloaded the CIFs for each of the COD entries, and calculated their diffraction patterns using Mercury. I am very pleased that the patterns produced by the code in this post match the patterns produced by Mercury!</p>
</section>
<section id="conclusions" class="level1">
<h1>Conclusions</h1>
<p>In this post, we’ve developed some code to allow us to read in unit cells, Miller indices, crystal system information and intensities, and rapidly generate realistic looking powder X-ray diffraction data on a GPU.</p>
<p>I’ve put all the functions written in this code into a github repository which can be found here - <a href="https://github.com/mspillman/powcodgen/">https://github.com/mspillman/powcodgen/</a> - please feel free to submit issues, pull requests etc if you have any ideas or suggestions for improvement!</p>
<p>In future posts, I’ll show how such data can be used to train artificial neural networks to do lots of interesting and useful things to help crystallographers understand their data.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>